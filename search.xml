<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL</title>
      <link href="/posts/jdis324/"/>
      <url>/posts/jdis324/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p><strong>学习视频：</strong><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru/">https://www.bilibili.com/video/BV1Kr4y1i7ru/</a></p><p>数据库就是存放数据的仓库，负责存储、管理和检索数据。</p><p><strong>学习要求：</strong></p><ol><li>能根据业务场景独立设计库表</li><li>熟练编写 SQL 语句</li></ol><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a>MySQL概述</h3><h4 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h4><table><thead><tr><th>名称</th><th>解释</th><th>简称</th></tr></thead><tbody><tr><td>数据库</td><td>数据存储的仓库，其中的数据是有组织的存储</td><td>DataBase（DB）</td></tr><tr><td>数据库管理系统</td><td>操纵和管理数据库的大型软件</td><td>DataBase Management System（DBMS）</td></tr><tr><td>SQL</td><td>操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准</td><td>Structured Query Language（SQL）</td></tr></tbody></table><p><strong>什么是关系型数据库？</strong></p><p>关系型数据库是依据关系模型来创建的数据库，简单来说关系就是二维表格。</p><h4 id="MySQL的安装"><a href="#MySQL的安装" class="headerlink" title="MySQL的安装"></a>MySQL的安装</h4><p>MySQL官方提供两个版本：</p><table><thead><tr><th>社区版（MySQL Community Server）</th><th>商业版（MySQL Enterprise Edition）</th></tr></thead><tbody><tr><td>免费，MySQL不提供任何技术支持</td><td>收费，官方提供技术支持</td></tr></tbody></table><p>Windows启动&#x2F;停止服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 管理员启动cmd</span><br><span class="line">// 启动</span><br><span class="line">net start mysql80</span><br><span class="line">// 关闭</span><br><span class="line">net stop mysql80</span><br></pre></td></tr></table></figure><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h4 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h4><ol><li>SQL语句可以单行也可以多行书写，以分号结尾。</li><li>SQL语句可以使用空格缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议大写。</li><li><strong>注释：</strong><ol><li>单行注释：<code>--</code>注释内容或<code>#</code>注释内容（MySQL特有）</li><li>多行注释：<code>/*注释内容*/</code></li></ol></li></ol><h4 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h4><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象（数据库，表，字段）</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据库操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据库查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据库控制语言，用来创建数据库用户、控制数据库的访问权限</td></tr></tbody></table><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231118143832020.png" alt="image-20231118143832020" style="zoom:70%;" /><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240112154801923.png" alt="image-20240112154801923"></p><h5 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h5><ul><li><p><strong>查询</strong></p><p>查询所有数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure><p>查询当前数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure></li><li><p><strong>删除</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE[IF <span class="keyword">EXISTS</span>] 数据库名;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建</strong></p><ul><li>CHARSET:指定数据库采用的字符集</li><li>COLLATE：指定数据库的排序规则</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [<span class="keyword">DEFAULT</span> CHARSET 字符集] [COLLLATE 排序规则];</span><br></pre></td></tr></table></figure></li></ul><h5 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h5><ul><li><p><strong>查询</strong></p><ol><li><p>查询当前数据库所有的表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure></li><li><p>查询表结构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>查询指定表的建表语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>创建</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型[ COMMENT 字段<span class="number">1</span>注释],</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型[ COMMENT 字段<span class="number">2</span>注释]</span><br><span class="line">)[ COMMENT 表注释];</span><br></pre></td></tr></table></figure></li><li><p><strong>修改</strong></p><ul><li><p>添加字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型 [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改数据类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改字段名和字段类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型 [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure></li><li><p>删除字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br></pre></td></tr></table></figure></li><li><p>修改表名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>删除</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>[ IF <span class="keyword">EXISTS</span>] 表名;</span><br><span class="line"><span class="comment">-- 删除指定表，并重新创建该表</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure></li></ul><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240113131353265.png" alt="image-20240113131353265" style="zoom:70%;" /><ul><li><p><strong>添加数据</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 给指定字段添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(字段<span class="number">1</span>，字段<span class="number">2</span>,...) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br><span class="line"><span class="comment">-- 给全部字段添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br><span class="line"><span class="comment">-- 批量添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(字段<span class="number">1</span>,字段<span class="number">2</span>,...) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的</li><li>字符串和日期型数据应该包含在引号中</li><li>插入的数据大小，应该在字段的规定范围内。</li></ul></li><li><p><strong>修改数据</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,...[ <span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure></li><li><p><strong>删除数据</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名[ <span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure></li></ul><h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><h5 id="DQL语法"><a href="#DQL语法" class="headerlink" title="DQL语法"></a>DQL语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">字段列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">分组后条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表<span class="number">7</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名 <span class="number">1</span></span><br><span class="line">连接类型 <span class="keyword">join</span> 表<span class="number">2</span> 别名  <span class="number">2</span></span><br><span class="line"><span class="keyword">on</span> 连接条件<span class="number">3</span></span><br><span class="line"><span class="keyword">where</span> 筛选条件<span class="number">4</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 分组列表<span class="number">5</span></span><br><span class="line"><span class="keyword">having</span> 分组后的筛选条件 <span class="number">6</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序列表<span class="number">8</span></span><br><span class="line">limit 起始条目索引,条目数; <span class="number">9</span></span><br></pre></td></tr></table></figure><h5 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h5><ul><li><p>查询多个字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,... <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="comment">-- 尽量不要写用 * ，1. 不直观 2. 影响效率</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>设置别名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>[<span class="keyword">AS</span> 别名<span class="number">1</span>], 字段<span class="number">2</span>[<span class="keyword">AS</span> 别名<span class="number">2</span>]... <span class="keyword">FROM</span> 表名；</span><br></pre></td></tr></table></figure><ul><li>AS 可以省略</li></ul></li><li><p>去除重复记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>当<code>distinct</code>应用到多个字段的时候，其应用的范围是其后面的所有字段，而不只是紧挨着它的一个字段，并且<code>distinct</code>只能放到所有字段的前面</li><li><code>distinct</code>不会去除空值</li></ul></li></ul><h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> 语法</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表;</span><br></pre></td></tr></table></figure><p><strong>条件</strong></p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;或!&#x3D;</td><td>不等于</td></tr><tr><td>BETWEEN…AND…</td><td>在摸个范围之内（含最小与最大）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（<code>_</code>匹配单个字符，<code>%</code>匹配多个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 ||</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr></tbody></table><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><blockquote><p>将一列数据作为一个整体，进行纵向计算。</p></blockquote><p><strong>常见聚合函数：</strong></p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段列表) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>NULL值不参与所有聚合函数的运算。</li></ul><h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h5><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后过滤条件];</span><br></pre></td></tr></table></figure><ul><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其它字段没有任何意义。</li></ul><h5 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h5><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>,字段<span class="number">2</span> 排序方式<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>排序方式：</strong></p><p>ASC：升序（默认值）</p><p>DESC：降序</p><ul><li>如果多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</li></ul><h5 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h5><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引,查询记录数;</span><br></pre></td></tr></table></figure><ul><li>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1）*每页显示记录数。</li><li>分页查询时数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10。</li></ul><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><blockquote><p>用来管理数据库用户、控制数据库的访问权限。</p></blockquote><h5 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h5><ul><li><p><strong>查询用户</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.user;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建用户</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>%</code> 表示任意主机</li></ul></li><li><p><strong>修改用户密码</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除用户</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h5><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL,ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表</td></tr></tbody></table><ul><li><p><strong>查询权限</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>授予权限</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>撤销权限</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong></p><ol><li>多个权限使用逗号进行分隔</li><li>授权时，数据库名和表名可以使用<code>*</code>进行通配，代表所有。</li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote><p>函数是指一段可以直接被另一端程序调用的程序或代码。</p></blockquote><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240113153409831.png" alt="image-20240113153409831"></p><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(S1,S2,…Sn)</td><td>字符串拼接</td></tr><tr><td>LOWER(str)</td><td>转小写</td></tr><tr><td>UPPER(str)</td><td>转大写</td></tr><tr><td>LPAD(str,n,pad)</td><td>左填充，用字符串pad对str的左边进行填充，到达n个字符串长度</td></tr><tr><td>RPAD(str,n,pad)</td><td>右填充，用字符串pad对str的右边进行填充，到达n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去除字符串头部与尾部的空格</td></tr><tr><td>SUBSTRING(str,start,len)</td><td>返回子串</td></tr></tbody></table><h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数0&lt; RAND() &lt;1</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入，保留y位小数</td></tr></tbody></table><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date,INTERVAL expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回date1和date2之间的天数</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 往后7个月</span></span><br><span class="line"><span class="keyword">select</span> date_add(now(),<span class="type">INTERVAL</span> <span class="number">7</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure><h4 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value,t,f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1,vaule2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [resl] … ELSE [ default] END</td><td>如果val1为true，返回res1，…否则返回default默认值0</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [resl] … ELSE [ default] END</td><td>如果expr的值等于val1，返回res1，否则返回default默认值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 例1：</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">CASE</span> id</span><br><span class="line">    <span class="keyword">WHEN</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="string">&#x27;00&#x27;</span></span><br><span class="line">    <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="string">&#x27;11&#x27;</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        <span class="string">&#x27;OTHERS&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> id_new</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    test</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例2：</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> id <span class="operator">&lt;</span> <span class="number">3</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="string">&#x27;&lt;3&#x27;</span></span><br><span class="line">    <span class="keyword">WHEN</span> id <span class="operator">&gt;=</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">AND</span> id <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="string">&#x27;&gt;=3 &amp;&amp; &lt;5&#x27;</span></span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        <span class="string">&#x27;&gt;=5&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> id_new</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    test</span><br></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><blockquote><p>约束是作用于表中字段上的规则，用于限制存储在表中的数据。保证数据库中数据的正确、有效和完整性。</p></blockquote><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.16版本以后）</td><td>保证字段满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr><tr><td>自增</td><td></td><td>AUTO_INCREMENT</td></tr></tbody></table><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">CONSTRAINT</span> 约束名称] <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY(外键名称) <span class="keyword">REFERENCES</span> 主表(主表列名);</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除外键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称;</span><br></pre></td></tr></table></figure><ul><li><p>删除&#x2F;更新行为</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应的外键，如果有则不允许删除&#x2F;更新。（与RESTRICT一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应的外键，如果有则不允许删除&#x2F;更新。（与NO ACTION一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应的外键，如果有则也删除&#x2F;更新外键所在子表中的记录。</td></tr><tr><td>SET NULL</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应的外键，如果有则设置子表中的该外键值为null（这要求允许外键为null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键列设置成一个默认的值（Innodb不支持）</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置行为</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY(外键名称) <span class="keyword">REFERENCES</span> 主表(主表列名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> 行为 <span class="keyword">ON</span> <span class="keyword">DELETE</span> 行为;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h4><h5 id="一对多（多对一）"><a href="#一对多（多对一）" class="headerlink" title="一对多（多对一）"></a>一对多（多对一）</h5><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240113173759376.png" alt="image-20240113173759376" style="zoom:100%;" /><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240113173900005.png" alt="image-20240113173900005" style="zoom:100%;" /><h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240113174033359.png" alt="image-20240113174033359" style="zoom:100%;" /><h4 id="多表查询概述"><a href="#多表查询概述" class="headerlink" title="多表查询概述"></a>多表查询概述</h4><blockquote><p>指从多张表中查询数据</p></blockquote><ul><li>笛卡尔积：笛卡尔乘积是指在数学中，两个集合A集合和B集合的所有组合情况。（在多表查询时，需要消除无效的笛卡尔积）</li></ul><p><strong>多表查询的分类</strong></p><ul><li>连接查询<ul><li>内连接：查询两张表交集部分数据</li><li>外连接<ul><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li></ul></li><li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul></li><li>子查  询</li></ul><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">WHERE</span> 条件...;</span><br><span class="line"><span class="comment">-- 显示内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件...;</span><br></pre></td></tr></table></figure><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件...;</span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件...;</span><br></pre></td></tr></table></figure><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><blockquote><p>就是把多次查询的结果合并起来，形成一个新的查询结果集。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1.</span>..</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">2.</span>..;</span><br></pre></td></tr></table></figure><ul><li>UNION ALL ：查询结果直接合并</li><li>UNION ：查询结果去重</li><li>列数与字段类型要保持一致</li></ul><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><blockquote><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p></blockquote><p>根据查询结果不同，可以分为：</p><ul><li><p><strong>标量子查询（子查询结果为单个值）</strong></p><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询成为标量子查询。</p><p>常用的操作符：&gt; 、&lt; 、&#x3D; 、!&#x3D;</p></li><li><p><strong>列子查询（子查询结果为一列）</strong></p><p>子查询返回的结果是一列，这种子查询称为列子查询。</p><p>常用的操作符：IN、NOT IN、ANY、SOME、ALL</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table></li><li><p><strong>行子查询（子查询结果为一行）</strong></p><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</p><p>常用的操作符有：&#x3D; 、&lt;&gt; 、 IN 、NOT IN</p><p>例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;z&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>表子查询（子查询结果为多行多列）</strong></p><p>子查询返回的结果是多行多列，这种子查询称为表子查询</p><p>常用的操作符：IN</p></li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的简介"><a href="#事务的简介" class="headerlink" title="事务的简介"></a>事务的简介</h4><blockquote><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p></blockquote><ul><li>默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</li></ul><h4 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><ul><li><p>查看&#x2F;设置事务提交的方式</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1 为自动提交， 2 为手动提交</span></span><br><span class="line"><span class="comment">-- 查看事务提交方式</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="comment">-- 设置事务提交方式</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> [<span class="keyword">TO</span> 回滚点];</span><br></pre></td></tr></table></figure></li><li><p>设置回滚点</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> 回滚点名;</span><br></pre></td></tr></table></figure></li></ul><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><ul><li><p>开启事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> [<span class="keyword">TO</span> 回滚点];</span><br></pre></td></tr></table></figure></li><li><p>设置回滚点</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> 回滚点名;</span><br></pre></td></tr></table></figure></li></ul><h4 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h4><ul><li><strong>原子性（Atomicity）</strong>：事务是不可分割的最小单元，要么全部成功，要么全部失败。</li><li><strong>一致性（Consistency）</strong>：事务完成时，必须使所有的数据都保持一致的状态。(一致的状态是数据库在事务执行前后满足预定义规则和约束、符合业务逻辑要求，并且数据完整且没有损坏的状态。)</li><li><strong>隔离性（Isolation）</strong>：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li><strong>持久性（Durability）</strong>：事务一旦提交或回滚，它对数据控中的数据的改变就是永久的。</li></ul><h4 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h4><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没有提交的数据。</td></tr><tr><td>不可重复度</td><td>一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读。</td></tr><tr><td>幻读</td><td>一个事务执行条件查询数据时，没有对应的数据行，但是在插入数据时，有法相这行数据已经存在，好像出现了幻影。</td></tr></tbody></table><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li><p>从上到下，隔离级别逐渐变高，性能逐渐变差</p></li><li><p>查看事务隔离级别</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@TRANSACTION_ISOLATION</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置事务隔离级别</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] TRANSACTION IOSLATION LEVEL [READ UNCOMMITTED<span class="operator">|</span>READ COMMITTED<span class="operator">|</span>REPEATABLE READ<span class="operator">|</span>SERIALIZABLE];</span><br></pre></td></tr></table></figure><ul><li>SESSION ：当前窗口有效</li><li>GLOBAL：全部窗口有效</li><li>默认是Repeatable Read</li></ul></li></ul><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h4><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240114233328517.png" alt="image-20240114233328517"></p><ul><li><p>连接层</p><p>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p></li><li><p>服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p></li><li><p>引擎层</p><p><strong>存储引擎真正的负责了MySQL中数据的存储和提取</strong>，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p></li><li><p>存储层</p><p>主要是将存储引擎存储在文件系统之上，并完成与存储引擎的交互。</p></li></ul><h4 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h4><blockquote><p>存储引擎是MySQL特有的，存储引擎就是存储数据、建立索引。更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p></blockquote><ol><li><p>在创建表时，指定存储引擎</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型 [COMMENT 字段<span class="number">1</span>注释],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB [COMMENT 表注释];</span><br></pre></td></tr></table></figure></li><li><p>查看当前数据库支持的存储引擎</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br></pre></td></tr></table></figure></li></ol><h4 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h4><h5 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h5><ul><li><strong>介绍</strong></li></ul><p>InnoDB是一种兼顾高可靠和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的存储引擎。</p><ul><li><strong>特点</strong></li></ul><ol><li>DML操作遵循ACID模型，支持事务；</li><li>行级锁，提高并发访问性能；</li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li></ol><ul><li><strong>文件</strong></li></ul><p><strong>xxx.ibd</strong>：xxx代表的是表名，innoDB引擎的每张表都对应这样一个表空间文件，存储该表结构（frm、sdi）、数据和索引。</p><p><strong>参数</strong>：innodb_file_per_table(决定是否多张表共用一个表空间)</p><p><strong>InnoDB逻辑存储结构</strong></p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240115001030015.png" alt="image-20240115001030015"></p><h5 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h5><ul><li><strong>介绍</strong></li></ul><p>MyISAM是MySQL早期的默认存储引擎。</p><ul><li><strong>特点</strong></li></ul><ol><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ol><ul><li><strong>文件</strong></li></ul><p><strong>xxx.sdi</strong>:存储表结构数据</p><p><strong>xxx.MYD</strong>:存储数据</p><p><strong>xxx.MYI</strong>:存储索引</p><h5 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h5><ul><li><strong>介绍</strong></li></ul><p>Memory引擎的表数据存储在内存中，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存表使用。</p><ul><li><strong>特点</strong></li></ul><ol><li>内存存放</li><li>hash索引（默认）</li></ol><ul><li><strong>文件</strong></li></ul><p><strong>xxx.sdi</strong>:存储表结构信息</p><p>数据存在内存中</p><h5 id="存储引擎特点-1"><a href="#存储引擎特点-1" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h5><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240115002014097.png" alt="image-20240115002014097"></p><h4 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h4><p><mark>在选择存储引擎时，因该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</mark></p><ul><li><strong>InnoDB</strong>：是MySQL的默认存储引擎，支持事务、外键。如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li><li><strong>MyISAM</strong>：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事物的完整性、并发性要求不是很高，那么选择这个存储引擎是合适的。（使用不高，基本使用MongoDB）</li><li><strong>MEMORY</strong>：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。（使用不高，基本使用Redis）</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h4><ul><li><strong>介绍</strong></li></ul><p>索引（index）是帮助MySQL高效获取数据的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><ul><li><strong>优缺点</strong></li></ul><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库的IO成本</td><td>索引列也是要占用空间的</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</td><td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低</td></tr></tbody></table><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><blockquote><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种</p></blockquote><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td><mark>B+Tree索引</mark></td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash索引</td><td>底层数据结构是用哈希表实现的，只要精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-tree(空间索引)</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间类型，通常使用较少</td></tr><tr><td>Full-text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于Lucene，Solr，ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree（空间索引）</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text（全文索引）</td><td>5.6后的版本支持</td><td>支持</td><td>不支持</td></tr></tbody></table><ul><li><strong>B+Tree</strong></li></ul><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><p><strong>根节点</strong>：只存储key、指针（每个指针都会指向一页），而指针永远都会比key多一个—–&gt;叶子节点：1.所有的元素都会出现在叶子节点中并形成一个单向链表（mysql中为双向链表）2.叶子节点才会存储数据</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240115115813135.png" alt="image-20240115115813135"></p><ul><li><strong>Hash</strong></li></ul><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p><p>特点</p><ol><li>Hash索引只能用于对等比较（&#x3D;，in），不支持范围查询（between，&gt;,&lt;,…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索，效率通常要高于B+tree索引</li></ol><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的重复值</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特殊值</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引（Clustered Index）</td><td>将数据存储与索引放到一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引（Secondary Index）</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则：</p><ol><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li></ol><p><strong>例子</strong></p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240115122026447.png" alt="image-20240115122026447"></p><h4 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h4><ul><li><p>创建索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 关联一个字段为单列索引，多个字段为联合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT] INDEX index_name <span class="keyword">ON</span> table_name (index_col_name,...);</span><br></pre></td></tr></table></figure></li><li><p>查看索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure></li></ul><h4 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h4><ul><li><p><strong>SQL执行频率</strong></p><p>MySQL客户端连接成功后，通过<code>show [session|global] status</code>命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br><span class="line"><span class="comment">--七个&#x27;_&#x27;模糊匹配</span></span><br></pre></td></tr></table></figure></li><li><p><strong>慢查询日志</strong></p><p>慢查询日志记录了所有执行时间超过指定参数(long_query_time,单位：秒，默认10秒) 的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看慢查询信息</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 开启慢查询</span></span><br><span class="line"><span class="keyword">set</span> [session<span class="operator">|</span><span class="keyword">global</span>] slow_query_log<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"><span class="comment">-- 设置慢查询时限(/秒)</span></span><br><span class="line"><span class="keyword">set</span> long_query_time<span class="operator">=</span>xx;</span><br></pre></td></tr></table></figure><p>配置文件在<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>中。</p></li><li><p><strong>profile详情</strong></p><p><code>show profiles</code> 能在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询是否支持</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have_profiling</span>;</span><br><span class="line"><span class="comment">-- 默认profiling是关闭的，可以通过set语句在session/global级别开启profiling</span></span><br><span class="line"><span class="comment">-- 查看profiling</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@profiling</span>;</span><br><span class="line"><span class="keyword">SET</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看每一条SQL的耗时基本情况</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"><span class="comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="operator">&lt;</span>query_id<span class="operator">&gt;</span>;</span><br><span class="line"><span class="comment">-- 查看指定query_id的SQL语句CPU使用情况</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query  <span class="operator">&lt;</span>query_id<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>explain执行计划</strong></p><p>EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。</p><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 直接在<span class="keyword">select</span>语句之前加上关键字explain<span class="operator">/</span><span class="keyword">desc</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure><p><strong>explain执行计划</strong></p><p>EXPLAIN执行计划各字段含义：</p><ul><li><p><strong>id</strong></p><p>select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）。</p></li><li><p>select_type</p><p>表示SELECT的类型。</p></li><li><p><strong>tyep</strong></p><p>查询使用了何种类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all</p><p>NULL:不涉及表操作</p><p>system：系统表</p><p>const：主键查询，唯一性索引查询</p><p>ref：非唯一性索引查询</p><p>all：全表扫描</p></li><li><p><strong>possible_key</strong></p><p>表示在<code>MySQL</code>中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，<strong>但这个索引并不定一会是最终查询数据时所被用到的索引</strong>。</p></li><li><p><strong>key</strong></p><p>key是查询中实际使用到的索引，若没有使用索引，显示为<code>NULL</code></p></li><li><p><strong>key_len</strong></p><p>表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</p></li><li><p><strong>rows</strong></p><p>MySQL认为必须要执行查询的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的,一般情况下 <code>rows</code> 值越小越好。</p></li><li><p>filtered</p><p>表示返回结构的行数占需读取行数的百分比，filtered的值越大越好</p></li><li><p><strong>Extra</strong></p><p>额外信息</p></li></ul></li></ul><h4 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h4><ul><li><p><strong>最左前缀法则</strong></p><p>如果索引了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。</p><p>如果跳过某一列，索引将部分失效（后面的字段索引失效）</p></li><li><p><strong>范围查询</strong></p><p>联合索引中，出现范围查询（&gt;,&lt;）,**范围查询右侧的列索引失效**（&gt;&#x3D;或&lt;&#x3D;不失效）</p></li><li><p><strong>索引列运算</strong></p><p>不要在索引列上进行运算操作，<strong>索引将失效</strong>。</p></li><li><p><strong>字符串不加引号</strong></p><p>字符串类型字段使用时，不加引号，索引失效</p></li><li><p><strong>模糊查询</strong></p><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... <span class="keyword">like</span> <span class="string">&#x27;软件%&#x27;</span>;  # 索引不失效</span><br><span class="line">... <span class="keyword">like</span> <span class="string">&#x27;%软件&#x27;</span>;  # 索引失效</span><br></pre></td></tr></table></figure></li><li><p><strong>or连接条件</strong></p><p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及索引都不会用到。</p></li><li><p><strong>数据分布影响</strong></p><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p></li><li><p><strong>SQL提示</strong></p><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些认为的提示来达到优化操作的目的。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- use index 建议索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line"><span class="comment">-- ignore index 忽略索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line"><span class="comment">-- force index 强制索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro)<span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>覆盖索引</p><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少select *。</p></li></ul><h4 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h4><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h3 id="视图-存储过程-触发器"><a href="#视图-存储过程-触发器" class="headerlink" title="视图&#x2F;存储过程&#x2F;触发器"></a>视图&#x2F;存储过程&#x2F;触发器</h3><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h3 id="InnoDB核心"><a href="#InnoDB核心" class="headerlink" title="InnoDB核心"></a>InnoDB核心</h3><h3 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h3><h2 id="运维篇"><a href="#运维篇" class="headerlink" title="运维篇"></a>运维篇</h2><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能云计算复习</title>
      <link href="/posts/idek234jld/"/>
      <url>/posts/idek234jld/</url>
      
        <content type="html"><![CDATA[<h2 id="并行计算概述"><a href="#并行计算概述" class="headerlink" title="并行计算概述"></a>并行计算概述</h2><h3 id="什么是并行计算？"><a href="#什么是并行计算？" class="headerlink" title="什么是并行计算？"></a>什么是并行计算？</h3><p>并行计算（Parallel Computing）,同义词：高性能计算（High Performance Computing）、超级计算（Super Computing）</p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226115253294.png" alt="image-20231226115253294" style="zoom:0%;" /><p>​在并行机上，将一个应用分解成多个子任务，分配给不同的处理器，各个处理器之间相互协同，并行地执行子任务，从而达到加速求解速度，或者求解应用问题。</p><h3 id="基本条件"><a href="#基本条件" class="headerlink" title="基本条件"></a>基本条件</h3><ol><li><p><strong>硬件（并行机）：</strong></p><p>并行机至少包含两台或两台以上处理机，这些处理机通过互连网络相互连接，相互通信。</p></li><li><p><strong>并行算法设计：</strong></p><p>也就是说，应用可以分解为多个子任务，这些子任务可以并行地执行。将一个应用分解为多个子任务的过程，称为并行算法的设计。</p></li><li><p><strong>并行编程环境：</strong></p><p>在并行机提供的并行编程环境上，具体实现并行算法，编制并行程序，并运行该程序，从而达到并行求解应用问题的目的。</p></li></ol><h3 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标"></a>主要目标</h3><ol><li><p><strong>提高求解速度：</strong></p><p>例如，在单处理器上，串行执行需要2 个星期（14 天），借助并行计算，使用100 台处理器，加速50 倍，将执行时间缩短为6.72 个小时。</p></li><li><p><strong>扩大问题规模：</strong></p><p>例如，在单处理器上，受内存资源2GB的限制，只能计算10 万个网格，也可以借助并行计算，使用100 个处理器，将问题求解规模线性地扩大100 倍。</p></li></ol><h2 id="并行计算体系结构（1）"><a href="#并行计算体系结构（1）" class="headerlink" title="并行计算体系结构（1）"></a>并行计算体系结构（1）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="并行计算机网络性能指标"><a href="#并行计算机网络性能指标" class="headerlink" title="并行计算机网络性能指标"></a>并行计算机网络性能指标</h4><ul><li><p><strong>节点度（Node Degree）</strong>：射入或射出一个节点的边数。在单向网络中，入射和出射边之和称为节点度。</p></li><li><p><strong>网络直径（Network Diameter）</strong>： 网络中任何两个节点之间的最长距离，即最大路径数。</p></li><li><p><strong>对剖宽度（Bisection Width）</strong> ：对分网络各半所必须移去的最少边数</p></li><li><p>如果从任一节点观看网络都一样，则称网络为<strong>对称的（Symmetry）</strong> </p></li><li><p><strong>对剖带宽（ Bisection Bandwidth）</strong>:每秒钟内，在最小的对剖平面上通过所有连线的最大信息位（或字节）数</p></li><li><p><strong>网络规模</strong>：网络包含的结点总数，或者包含的CPU 总数。</p></li></ul><p>​在固定网络规模的情况下，对剖带宽越高、对剖宽度越大、网络直径越小，则互联网络的质量就越高。</p><h3 id="静态互联网络"><a href="#静态互联网络" class="headerlink" title="静态互联网络"></a>静态互联网络</h3><h4 id="静态连接"><a href="#静态连接" class="headerlink" title="静态连接"></a>静态连接</h4><blockquote><p>处理单元间有着固定连接的一类网络，在程序执行期间，这种点到点的链接保持不变</p></blockquote><p>• 典型的静态网络</p><p><strong>一维线性阵列</strong>、<strong>二维网孔</strong>、<strong>树连接</strong>、<strong>超立方网络</strong>、<strong>立方环</strong>等。</p><h4 id="一维线性阵列"><a href="#一维线性阵列" class="headerlink" title="一维线性阵列"></a>一维线性阵列</h4><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226135837823.png" alt="image-20231226135837823" style="zoom:70%;" /><h4 id="二维网孔"><a href="#二维网孔" class="headerlink" title="二维网孔"></a>二维网孔</h4><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226140100808.png" alt="image-20231226140100808" style="zoom:70%;" /><p><strong>改进：</strong></p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226140415464.png" alt="image-20231226140415464" style="zoom:70%;" /><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226140952854.png" alt="image-20231226140952854" style="zoom:67%;" /><ul><li><p><strong>标准二叉树拓扑结构包含P&#x3D;2^N个叶结点和2^N-1个内结点</strong></p><ul><li><p><strong>叶结点分别对应并行机的结点；</strong></p></li><li><p><strong>内结点负责这些叶结点之间的通信。</strong></p></li></ul></li><li><p><strong>二叉树的网络直径仅为2 log P，非常有利于叶结点之间的全局通信。</strong></p></li><li><p><strong>它的折半宽度只为1，不利于结点之间的大数据量通信。</strong></p></li></ul><p><strong>改进：</strong>（胖树）</p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226141324784.png" alt="image-20231226141324784" style="zoom:67%;" /><h4 id="超立方"><a href="#超立方" class="headerlink" title="超立方"></a>超立方</h4><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226141805807.png" alt="image-20231226141805807" style="zoom:67%;" /><ul><li>是一个具有很好性质的拓扑结构，其网络直径仅为logP，折半带宽为2^(d-1)。</li><li>结点的度为d，随并行机规模的增加而增加，这给网络实现带来了一定的困难。</li><li>通常地，超立方体一般不超过5 维。</li></ul><h4 id="k-立方环"><a href="#k-立方环" class="headerlink" title="k-立方环"></a>k-立方环</h4><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226142359184.png" alt="image-20231226142359184" style="zoom:67%;" /><h4 id="静态互联网络特性比较（记）"><a href="#静态互联网络特性比较（记）" class="headerlink" title="静态互联网络特性比较（记）"></a>静态互联网络特性比较（记）</h4><p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226141546978.png" alt="image-20231226141546978"></p><h3 id="动态互联网络"><a href="#动态互联网络" class="headerlink" title="动态互联网络"></a>动态互联网络</h3><p>···</p><h2 id="并行计算体系结构（2）"><a href="#并行计算体系结构（2）" class="headerlink" title="并行计算体系结构（2）"></a>并行计算体系结构（2）</h2><h3 id="Flynn分类"><a href="#Flynn分类" class="headerlink" title="Flynn分类"></a>Flynn分类</h3><p>指令流&#x2F;数据流分类法，即<strong>费林-Flynn</strong>分类法。（计算机系统分类）</p><p>（1）<strong>指令流（Instruction Stream）</strong>：机器执行的指令序列。</p><p>（2）<strong>数据流（Data Stream）</strong>：指令调用的数据序列，包括输入数据和中间结果。</p><p>（3）<strong>多倍性（Multiplicity）</strong>：在系统性能瓶颈部件上同时处于同一执行阶段的指令或数据的最大可能个数。</p><hr><p>• 两个独立的维度——指令流和数据流的不同组织方式，将<strong>计算机系统</strong>分为四类：</p><ul><li><p>单指令单数据流（Single Instruction stream and Single Data stream , SISD）系统</p></li><li><p>单指令多数据流（Single Instruction stream and Multiple-Data stream , SIMD）系统</p></li><li><p>多指令单数据流（Multiple-Instruction stream and Single Data stream , MISD）系统</p></li><li><p>多指令多数据流（Multiple-Instruction stream and Multiple-Data stream , MIMD）系统</p></li></ul><p>• SISD：SISD系统是一种传统的顺序执行的单处理器计算机，它的硬件不支持任何形式的并行计算，所有的指令都是串行执行。在任何一个时钟周期内，CPU只能处理一个数据流，因此这种机器被称作单指令流单数据流机器</p><p>• SIMD：SIMD系统有多个处理单元，由单一的指令部件控制，按照同一指令流的要求为它们分配各不相同的数据流并进行处理。系统结构由一个控制器、多个处理器、多个存储模块和一个互连总线（网络）组成</p><p>• MISD：MISD系统有多个处理单元，每个处理单元按照多条不同的指令要求同时对同一数据流及其处理输出的结果进行不同的处理，把一个单元的输出作为另一个单元的输入</p><p>• MIMD ：MIMD系统又称为多处理机系统，是指能实现指令、数据作业、任务等各级全面并行计算的多机处理系统，可以将一个主任务分解为众多子任务并行执行以缩短工作时间</p><h3 id="内存访问模型"><a href="#内存访问模型" class="headerlink" title="内存访问模型"></a>内存访问模型</h3><h4 id="并行计算机的体系结构"><a href="#并行计算机的体系结构" class="headerlink" title="并行计算机的体系结构"></a>并行计算机的体系结构</h4><ul><li>组成要素<ul><li><strong>处理器（processor）</strong>:计算单元</li><li><strong>互联网络（interconnect network）</strong>:连接</li><li><strong>内存（memory）</strong>:多个存储模块的组成</li></ul></li></ul><p>并行机的基本特征是具备多个<strong>计算单元</strong>和<strong>存储模块</strong>，各个模块通过互联网络耦合</p><ul><li>根据耦合的紧密程度可分为紧耦合和松耦合。</li><li>不同的并行计算机，其各模块耦合的松紧程度可以有区别</li></ul><h4 id="共享内存vs分布式内存"><a href="#共享内存vs分布式内存" class="headerlink" title="共享内存vs分布式内存"></a>共享内存vs分布式内存</h4><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227122738905.png" alt="image-20231227122738905" style="zoom:60%;" /><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227131409871.png" alt="image-20231227131409871" style="zoom:70%;" /><p>​通常也称为紧密耦合多处理机，它具有一个所有处理器都可以访问的全局物理内存。</p><p><strong>共享内存系统的特性有：</strong></p><ol><li><strong>对称性</strong>：系统中任何处理器都可以访问任何的内存单元和I&#x2F;O设备</li><li><strong>单地址空间</strong>：内存中每一个位置在整个的内存地址范围内有一个唯一的地址</li><li><strong>低通信延迟</strong>：处理器间的通信可以利用共享内存来进行数据交换</li><li><strong>高速缓存及其一致性</strong>：多级高速缓存可以支持数据的局部性，而其一致性可由硬件来增强</li></ol><h4 id="分布式内存"><a href="#分布式内存" class="headerlink" title="分布式内存"></a>分布式内存</h4><p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227162708832.png" alt="image-20231227162708832"></p><ul><li>分布式内存系统中处理器都有各自的内部寄存器，一个核内的内存地址对其他核不可见，只能由该处理器所访问，对于所有CPU都没有单一全局地址空间的概念，这类的分布式计算机系统称为非远程存储访问（No-Remote Memory Access, NORMA）</li></ul><h4 id="并行计算机访问模型"><a href="#并行计算机访问模型" class="headerlink" title="并行计算机访问模型"></a>并行计算机访问模型</h4><ul><li>UMA（Uniform Memory Access）模型：均匀存储访问模型。</li><li>NUMA（Non-Uniform Memory Access）模型：非均匀存储访问模型。</li><li>COMA（Cache-Only Memory Access）模型：全高速缓存存储访问。</li><li>CC-NUMA（Coherent-Cache Nonuniform Memory Access）模型：高速缓存一致性非均匀存储访问模型。</li><li>NORMA（No-Remote Memory Access）模型：非远程存储访问模型。</li></ul><h4 id="UMA（Uniform-Memory-Access）"><a href="#UMA（Uniform-Memory-Access）" class="headerlink" title="UMA（Uniform Memory Access）"></a>UMA（Uniform Memory Access）</h4><p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227144312553.png" alt="image-20231227144312553"></p><ul><li><p>物理存储器被所有处理器均匀共享；</p></li><li><p>所有处理器访问任何存储字取相同的时间；</p></li><li><p>每台处理器可带私有高速缓存；</p></li><li><p>外围设备(I&#x2F;O)也可以一定形式共享；</p></li><li><p>发生访存竞争时，仲裁策略平等对待每个结点，即每个结点机会均等；</p></li></ul><h4 id="NUMA（Non-Uniform-Memory-Access）"><a href="#NUMA（Non-Uniform-Memory-Access）" class="headerlink" title="NUMA（Non-Uniform Memory Access）"></a>NUMA（Non-Uniform Memory Access）</h4><p>非均匀存储访问</p><p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227160342362.png" alt="image-20231227160342362"></p><ul><li><p>被共享的存储器在物理上是分布在所有的处理器中的，其所有本地存储器的集合就组成了全局地址空间；</p></li><li><p>处理器访问存储器时间是不一样的；</p></li><li><p>每台处理器照例可带私有高速缓存。</p></li></ul><h4 id="CC-NUMA（高速缓存一致性非均匀存储访问模型）"><a href="#CC-NUMA（高速缓存一致性非均匀存储访问模型）" class="headerlink" title="CC-NUMA（高速缓存一致性非均匀存储访问模型）"></a>CC-NUMA（高速缓存一致性非均匀存储访问模型）</h4><p>Coherent-Cache Nonuniform Memory Access</p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227161724363.png" alt="image-20231227161724363" style="zoom: 70%;" /><p><strong>特点：</strong></p><ul><li>大多数使用基于目录的高速缓存一致性协议；</li><li>保留SMP结构易于编程的优点，也改善常规SMP的扩张性；</li><li>CC-NUMA实际上是一个分布共享存储的DSM多处理机系统;</li><li>它最显著的优点是程序员无需明确地在节点上分配数据，系统的硬件和软件开始时自动在各节点分配数据，在运行期间，高速缓存一致性硬件会自动地将数据迁移至要用到它的地方。</li></ul><h4 id="COMA"><a href="#COMA" class="headerlink" title="COMA"></a>COMA</h4><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227162513786.png" alt="image-20231227162513786" style="zoom:67%;" /><p>特例：全高速缓存存储访问（Cache-Only Memory Access, COMA）模型，COMA各个处理器节点没有存储层次结构，所有节点的高速缓存构成了全局地址空间</p><h4 id="NORMA-（非远程存储访问）"><a href="#NORMA-（非远程存储访问）" class="headerlink" title="(NORMA)（非远程存储访问）"></a>(NORMA)（非远程存储访问）</h4><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227162951105.png" alt="image-20231227162951105" style="zoom:50%;" /><p><strong>优点：</strong></p><ol><li>内存可以随着CPU的数量进行扩展，增加处理器数量将使内存的大小等比例增加</li><li>各个处理器可以无冲突地快速访问自己的内存，也不存在维护缓存一致性的开销</li><li>成本效益上，可以使用商用、现成的处理器和网络</li></ol><p><strong>局限性：</strong></p><ol><li>程序员将要负责所有处理器间数据通信相关的细节问题</li><li>很难从基于全局内存空间的数据结构上建立起到分布式内存管理的映射。</li><li>非一致的内存访问时间使得驻留在远程节点上的数据比节点本地数据的访问需要更长时间。</li></ol><h4 id="PVP（Parallel-Vector-Processor）"><a href="#PVP（Parallel-Vector-Processor）" class="headerlink" title="PVP（Parallel Vector Processor）"></a>PVP（Parallel Vector Processor）</h4><p>并行向量处理器</p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227150433907.png" alt="image-20231227150433907" style="zoom: 80%;" /><h4 id="SMP（Symmetric-Multiprocessing）"><a href="#SMP（Symmetric-Multiprocessing）" class="headerlink" title="SMP（Symmetric Multiprocessing）"></a>SMP（Symmetric Multiprocessing）</h4><p>对称多处理器</p><ul><li>内存模块和处理器对称地分布在互联网络的两侧; </li><li>内存访问属典型的均匀访问模型。</li></ul><p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227150541462.png" alt="image-20231227150541462"></p><p><strong>特点：</strong></p><p>优点：</p><ul><li><p>对称共享存储</p><p>系统中任何处理器均可直接访问任何存储模块中的存储单元和I&#x2F;O 模块，且访问的延迟、带宽和访问成功的概率是一致的。所有内存单元统一编址。各个处理器之间的地位等价，不存在任何特权处理器。操作系统可在任意处理器上运行。</p></li><li><p>单一的操作系统映像</p><p>全系统只有一个操作系统驻留在共享存储器中，它根据各个处理器的负载情况，动态地分配各个进程到各个处理器，并保持各处理器间的负载平衡。 </p></li><li><p>局部高速缓存cache 及其数据一致性</p><p>每个处理器均配备局部cache，它们可以拥有独立的局部数据，但是这些数据必须与存储器中的数据保持一致。</p></li><li><p>低通信延迟</p><p>各进程通过读&#x2F;写操作系统提供的共享数据缓存区来完成处理器间的通信，其延迟通常小于网络通信的延迟。</p></li><li><p>共享总线带宽</p><p>所有处理器共享总线的带宽，完成对内存模块和I&#x2F;O 模块的访问。 </p></li><li><p>支持消息传递、共享存储并行程序设计。</p></li></ul><p>缺点：</p><ul><li><p>欠可靠</p><p>总线、存储器或操作系统失效可导致系统崩溃。 </p></li><li><p>可扩展性（scalability）较差</p><p>由于所有处理器共享总线带宽，而总线带宽每3 年才增加2 倍，跟不上处理器速度和内存容量的增加步伐，因此，SMP 并行机的处理器个数一般少于32 个，且只能提供每秒数百亿次的浮点运算性能。</p></li></ul><h4 id="大规模并行处理机（Massively-Parallel-Processor，MPP）"><a href="#大规模并行处理机（Massively-Parallel-Processor，MPP）" class="headerlink" title="大规模并行处理机（Massively Parallel Processor，MPP）"></a>大规模并行处理机（Massively Parallel Processor，MPP）</h4><ul><li>由大规模“紧密”互连的节点组成的</li><li>内存访问属于非远程访问模型（NORMA）</li><li>也被称为“message-passing”系统</li></ul><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227170058680.png" alt="image-20231227170058680" style="zoom:50%;" /><ul><li><p>由数百个乃至数千个计算结点和I&#x2F;O 结点组成，每个结点相对独立，并拥有一个或多个微处理器。</p><ul><li><p>这些结点配备有局部cache，并通过局部总线或互联网络与局部内存模块和I&#x2F;O设备相连接。</p></li><li><p>这些结点由局部高性能网卡(NIC)通过高性能互联网络相互连接。</p></li><li><p>各个结点均拥有不同的操作系统映像。</p><ul><li>一般情况下，用户可以将作业提交给作业管理系统，由它负责调度当前最空闲、最有效的计算结点来执行该作业。但是，MPP也允许用户登录到某个特定的结点，或在某些特定的结点上运行作业。</li></ul></li><li><p>各个结点间的内存模块相互独立，且不存在全局内存单元的统一硬件编址。</p></li><li><p>仅支持消息传递或者高性能Fortran并行程序设计，不支持全局共享的OpenMP并行程序设计模式。</p></li></ul></li></ul><h4 id="集群、机群（Cluster）-COW"><a href="#集群、机群（Cluster）-COW" class="headerlink" title="集群、机群（Cluster）&#x2F;COW"></a>集群、机群（Cluster）&#x2F;COW</h4><ul><li><p>松耦合。分布式存储，MIMD，工作站+商用互连网络，每个节点是一个完整的计算机，有自己的磁盘和操作系统。 </p></li><li><p>优点：</p><ul><li><p>投资风险小</p></li><li><p>系统结构灵活</p></li><li><p>性能&#x2F;价格比高</p></li><li><p>能充分利用分散的计算资源</p></li><li><p>可扩放性好</p></li></ul></li><li><p>问题</p><ul><li><p>通信性能</p></li><li><p>并行编程环境</p></li></ul></li></ul><p>例子：Berkeley NOW，Alpha Farm, FXCOW</p><h4 id="MPP-vs-Cluster"><a href="#MPP-vs-Cluster" class="headerlink" title="MPP vs Cluster"></a>MPP vs Cluster</h4><ul><li><p>Cluster的每个结点都是一台完整的计算机。 Cluster的每个结点上都有完整的操作系统，而MPP的每个结点上通常只有操作系统的微核。 Cluster的网络和操作系统均不是定制的。</p></li><li><p>Cluster的每个结点内有本地磁盘，而MPP的结点内没有。</p></li><li><p>Cluster各结点的网络接口是连接到I&#x2F;O总线上的（松耦合），而MPP各结点的网络接口是连接到存储总线上的（紧耦合）。</p></li></ul><h4 id="DSM（Distributed-Shared-Memory-，DSM）"><a href="#DSM（Distributed-Shared-Memory-，DSM）" class="headerlink" title="DSM（Distributed Shared Memory ，DSM）"></a>DSM（Distributed Shared Memory ，DSM）</h4><h4 id="内存体系"><a href="#内存体系" class="headerlink" title="内存体系"></a>内存体系</h4><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227151511495.png" alt="image-20231227151511495" style="zoom:80%;" /><h4 id="五种结构特性"><a href="#五种结构特性" class="headerlink" title="五种结构特性"></a>五种结构特性</h4><p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227145147243.png" alt="image-20231227145147243"></p><h2 id="并行计算模型及性能评测"><a href="#并行计算模型及性能评测" class="headerlink" title="并行计算模型及性能评测"></a>并行计算模型及性能评测</h2><h3 id="并行计算模型"><a href="#并行计算模型" class="headerlink" title="并行计算模型"></a>并行计算模型</h3><blockquote><p>将并行计算机的基本特征抽象出来，形成一个抽象的计算模型，作为并行算法分析、设计、性能预测的基础。</p></blockquote><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231228152740124.png" alt="image-20231228152740124" style="zoom: 70%;" /><h4 id="PRAM模型"><a href="#PRAM模型" class="headerlink" title="PRAM模型"></a>PRAM模型</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><blockquote><p>由Fortune和Wyllie1978年提出，又称SIMD-SM模型。有一个集中的共享存储器和一个指令控制器，通过SM的R&#x2F;W交换数据，隐式同步计算。</p></blockquote><p>Parallel Random Access Machine</p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231228153658490.png" alt="image-20231228153658490" style="zoom:67%;" /><p><strong>优点</strong></p><ul><li>适合并行算法表示和复杂性分析，易于使用，隐藏了并行机的通讯、同步等细节。</li></ul><p><strong>缺点</strong></p><ul><li>不适合MIMD并行机，忽略了SM的竞争、通讯延迟等因素</li></ul><h4 id="BSP模型"><a href="#BSP模型" class="headerlink" title="BSP模型"></a>BSP模型</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><blockquote><p>由Valiant(1990)提出的，“块”同步模型，是一种异步MIMD-DM模型，支持消息传递系统，块内异步并行，块间显式同步。</p></blockquote><p><strong>模型参数：</strong></p><ul><li><p><em>p</em>：处理器数(带有存储器) </p></li><li><p><em>l</em>：同步障时间(Barrier synchronization time)</p></li><li><p><em>g</em>：带宽因子(time steps&#x2F;packet)&#x3D;1&#x2F;bandwidth</p></li></ul><p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231228164008242.png" alt="image-20231228164008242"></p><h4 id="LogP模型"><a href="#LogP模型" class="headerlink" title="LogP模型"></a>LogP模型</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>由Culler(1993)年提出的，是一种分布存储的、点到点通讯的多处理机模型，其中通讯由一组参数描述，实行隐式同步。</p><p><strong>模型参数：</strong></p><ul><li>L(Latency) 表示源处理机与目的处理机进行消息（一个或几个字）通信所需要的等待或延迟时间的上限，表示网络中消息的延迟。</li><li>o(overhead)表示处理机准备发送或接收每个消息的时间开销（包括操作系统核心开销和网络软件开销），在这段时间里处理不能执行其它操作。</li><li>g(gap)表示一台处理机连续两次发送或接收消息时的最小时间间隔，其倒数即微处理机的通信带宽。</li><li>P(Processor)处理机&#x2F;存储器模块个数</li></ul><p><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231228165212076.png" alt="image-20231228165212076"></p><p>注：<em>L</em>和<em>g</em>反映了通讯网络的容量</p><h3 id="性能评测"><a href="#性能评测" class="headerlink" title="性能评测"></a>性能评测</h3><blockquote><p>性能评测：性能评价和性能分析</p><p>• 性能评价和性能分析可以揭示高性能计算机、并行算法和并行应用程序的性能特点和性能瓶颈，指导高性能计算机、并行算法和应用程序的设计与改进</p></blockquote><h4 id="机器级性能评测"><a href="#机器级性能评测" class="headerlink" title="机器级性能评测"></a>机器级性能评测</h4><blockquote><p>CPU和存储器的某些基本性能指标；并行和通信开销分析；并行机的可用性与好用性以及机器成本、价格与性&#x2F;价比</p></blockquote><img src="https://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231228172728623.png" alt="image-20231228172728623" style="zoom:80%;" /><h4 id="算法级性能评测"><a href="#算法级性能评测" class="headerlink" title="算法级性能评测"></a>算法级性能评测</h4><ul><li><strong>加速比（Speedup）</strong>：对于一个给定的应用，并行算法（或并行程序）相对于串行算法（或串行程序）的性能提高程度。<ul><li>Amdahl定律</li><li>Gustafson定律</li><li>Sun Ni定律</li></ul></li></ul><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231228173545233.png" alt="image-20231228173545233"></p><ul><li><strong>可扩展性（Scalability）</strong>：当系统和问题的规模增大时，可维持相同性能的能力，即指应用、算法和结构能否充分利用不断增长的处理器的能力<ul><li>等效率度量标准</li><li>等速度度量标准</li><li>平均延迟度量标准</li></ul></li></ul><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231228173558266.png" alt="image-20231228173558266"></p><h5 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h5><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231228175033604.png" alt="image-20231228175033604" style="zoom: 80%;" /><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231228175459022.png" alt="image-20231228175459022" style="zoom:80%;" /><p><strong>增强的Amdahl定律</strong></p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231228175550576.png" alt="image-20231228175550576" style="zoom:80%;" /><h5 id="Gustafson定律"><a href="#Gustafson定律" class="headerlink" title="Gustafson定律"></a>Gustafson定律</h5><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231228210658231.png" alt="image-20231228210658231"></p><h5 id="Sun-Ni定律"><a href="#Sun-Ni定律" class="headerlink" title="Sun &amp; Ni定律"></a>Sun &amp; Ni定律</h5><h4 id="程序级性能评测"><a href="#程序级性能评测" class="headerlink" title="程序级性能评测"></a>程序级性能评测</h4><h5 id="等效率测速（Efficiency-Metrics）"><a href="#等效率测速（Efficiency-Metrics）" class="headerlink" title="等效率测速（Efficiency Metrics）"></a>等效率测速（Efficiency Metrics）</h5><ul><li>效率：加速比 &#x2F; 处理器数</li><li>简单情况下能得出分析结果</li></ul><h2 id="并行算法设计"><a href="#并行算法设计" class="headerlink" title="并行算法设计"></a>并行算法设计</h2><p>…</p><blockquote><p> PCAM设计方法学，并行算法的一般设计过程</p></blockquote><p>设计并行算法的四个阶段</p><ul><li>划分（Partitioning）</li><li>通信（Communication）</li><li>组合（Agglomeration）</li><li>映射（Mapping）</li></ul><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230164316589.png" alt="image-20231230164316589"></p><h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h3><p>划分方法描述</p><p>充分开拓算法的并发性和可扩放性；</p><p>分为两类划分：</p><ul><li><p>域分解(domain decomposition)&#x2F;数据分解</p></li><li><p>功能分解(functional decomposition)</p></li></ul><p>• 先进行数据分解(称域分解)，再进行计算功能的分解(称功能分解)； </p><p>• 使数据集和计算集互不相交</p><p>• 划分阶段忽略处理器数目和目标机器的体系结构</p><h4 id="域划分"><a href="#域划分" class="headerlink" title="域划分"></a>域划分</h4><ul><li><p>划分的<strong>对象是数据</strong>，可以是算法的输入数据、中间处理数据和输出数据</p></li><li><p>将数据分解成大致相等的小数据片</p></li><li><p>划分时考虑数据上的相应操作</p></li><li><p>如果一个任务需要别的任务中的数据，则会产生任务间的通信</p></li></ul><h4 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h4><ul><li><p>划分的<strong>对象是计算</strong>，将计算划分为不同的任务，其出发点不同于域分解；</p></li><li><p>划分后，研究不同任务所需的数据。</p><ul><li><p>如果这些数据不相交的，则划分是成功的；</p></li><li><p>如果数据有相当的重叠， 意味着要重新进行域分解和功能分解；</p></li></ul></li><li><p>功能分解是一种更深层次的分解。</p></li></ul><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><ul><li><p>通信是PCAM设计过程的重要阶段；</p></li><li><p>划分产生的诸任务，一般不能完全独立执行，需要在任务间进行数据交流；从而产生了通信；</p></li><li><p>功能分解确定了诸任务之间的数据流；</p></li><li><p>诸任务是并发执行的，通信则限制了这种并发性；</p></li></ul><h4 id="四种通信模式"><a href="#四种通信模式" class="headerlink" title="四种通信模式"></a>四种通信模式</h4><ul><li>局部&#x2F;全局通信（Local&#x2F;Global communication）</li><li>结构化&#x2F;非结构化通信（Structure&#x2F;Unstructured communication）</li><li>静态&#x2F;动态通信（Static&#x2F;Dynamic communication）</li><li>同步&#x2F;异步通信（Synchonous&#x2F;Asynchronous）</li></ul><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><ul><li><p>组合是由抽象到具体的过程，是使得组合的任务能在一类并行机上有效的执行</p></li><li><p>合并小尺寸任务，减少任务数。如果任务数恰好等于处理器数，则也完成了映射过程</p></li><li><p>通过增加任务的粒度和重复计算，可以减少通信成本</p></li><li><p>保持映射和扩展的灵活性，降低软件工程成本</p></li></ul><h4 id="表面-容积效应（Surface-to-Volume-Effects）"><a href="#表面-容积效应（Surface-to-Volume-Effects）" class="headerlink" title="表面-容积效应（Surface-to-Volume Effects）"></a>表面-容积效应（Surface-to-Volume Effects）</h4><ul><li>通信量与任务子集的表面成正比，计算量与任务子集的体积成正比</li><li>增加重复计算有可能减少通讯量</li></ul><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><ul><li><p>每个任务要映射到具体的处理器，定位到运行机器上；</p></li><li><p>任务数大于处理器数时，存在负载平衡和任务调度问题；</p></li><li><p>映射的目标：减少算法的执行时间</p><ul><li><p>并发的任务 -&gt; 不同的处理器</p></li><li><p>任务之间存在高通信的 -&gt; 同一处理器</p></li></ul></li></ul><p>• 映射实际是一种权衡，属于NP完全问题；</p><h4 id="两种策略"><a href="#两种策略" class="headerlink" title="两种策略"></a>两种策略</h4><ul><li><p>使得任务可以被不同的处理器并发地执行，增强并发性（concurrency） </p></li><li><p>将通信频繁的任务放到同一个处理器上，增强局部性 （locality）</p></li></ul><h4 id="负载平衡算法"><a href="#负载平衡算法" class="headerlink" title="负载平衡算法"></a>负载平衡算法</h4><p><img src="C:\Users\胡华裕\AppData\Roaming\Typora\typora-user-images\image-20231230180721598.png" alt="image-20231230180721598"></p><h4 id="任务调度算法"><a href="#任务调度算法" class="headerlink" title="任务调度算法"></a>任务调度算法</h4><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230180823162.png" alt="image-20231230180823162"></p><h2 id="并行程序设计基础"><a href="#并行程序设计基础" class="headerlink" title="并行程序设计基础"></a>并行程序设计基础</h2><h3 id="Cannon"><a href="#Cannon" class="headerlink" title="Cannon"></a>Cannon</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102203817028.png" alt="image-20240102203817028"></p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102203925846.png" alt="image-20240102203925846"></p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h2 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h2><p><strong>进程：</strong> 进程是操作系统资源分配的基本实体<br><strong>线程：</strong> 线程是CPU调度和分配的基本单位<br>在Linux系统下是没有线程的概念的，它是用进程模拟的线程，因此把线程叫做轻量级进程。</p><blockquote><p>OpenMP 是一个应用程序接口(API)，由一组主要的计算机硬件和软件供应商联合定义。OpenMP 为共享内存并行应用程序的开发人员提供了一个可移植的、可伸缩的模型。该API在多种体系结构上支持 C&#x2F;C++ 和 Fortran。</p></blockquote><h3 id="什么是OpenMP"><a href="#什么是OpenMP" class="headerlink" title="什么是OpenMP"></a>什么是OpenMP</h3><p><a href="https://www.jianshu.com/p/9931c05f4058">OpenMP中文教程 - 简书 (jianshu.com)</a></p><p><strong>OpenMP是：</strong></p><ul><li>一种应用程序接口(API)，可用于显式地指示多线程、<strong>共享内存</strong>并行性。</li><li>由三个主要的API组件组成：<ul><li>编译器指令</li><li>运行时库函数</li><li>环境变量</li></ul></li><li>Open Multi-Processing的缩写</li></ul><h3 id="Fork-Join模型"><a href="#Fork-Join模型" class="headerlink" title="Fork-Join模型"></a><code>Fork-Join</code>模型</h3><ul><li>OpenMP 使用并行执行的 fork-join 模型：</li></ul><p><img src="https://www.hz-bin.cn/assets/images/fork_join2.gif" alt="img"></p><ul><li>所有 OpenMP 程序都开始于一个主线程。主线程按顺序执行，直到遇到第一个并行区域结构。</li><li><strong>FORK</strong>：主线程然后创建一组并行线程。</li><li>之后程序中由并行区域结构封装的语句在各个团队线程中并行执行。</li><li><strong>JOIN</strong>：当团队线程完成并行区域结构中的语句时，它们将进行同步并终止，只留下主线程。</li><li>并行区域的数量和组成它们的线程是任意的。</li></ul><h3 id="编译器指令"><a href="#编译器指令" class="headerlink" title="编译器指令"></a>编译器指令</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><table><thead><tr><th>#pragma omp</th><th>directive-name</th><th>[clause, …]</th><th>newline</th></tr></thead><tbody><tr><td>所有 OpenMP C&#x2F;C++ 指令都需要。</td><td>一个有效的 OpenMP 指令。必须出现在 <code>pragma</code> 之后和任何子句之前。</td><td>可选的。除非另有限制，子句可以按任何顺序重复。</td><td>必需的。在此指令所包含的结构化块之前。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp 指令 [子句]</span></span><br></pre></td></tr></table></figure><p><strong>下面是一些常见的OpenMP编译器指令格式的示例：</strong></p><ol><li><code>#pragma omp parallel</code>：用于创建并行区域，指示编译器将其中的代码并行执行，并创建一个线程团队。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel [clause]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 并行执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>#pragma omp for</code>：用于并行化循环，将循环迭代分配给不同的线程执行。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for [clause]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环增量操作：循环增量操作会由编译器自动处理，保证每个线程独立地更新自己的循环变量。</li><li>如果循环体内部存在对共享变量的修改操作，可能会导致竞争条件。在这种情况下，需要使用适当的同步机制</li></ul><ol><li><code>#pragma omp critical</code>：用于标记一个临界区，保证在任意时刻只有一个线程可以进入该临界区。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>#pragma omp barrier</code>：用于插入一个隐式的同步点，确保所有线程在此处等待，直到所有线程都到达该点。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp barrier</span></span><br></pre></td></tr></table></figure><ol><li><code>#pragma omp parallel for</code>：结合了并行区域和循环并行化的指令，用于并行化循环并创建线程团队。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for [clause]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常用的子句如下：</strong></p><ul><li>num_threads(num)：指定并行域内线程的数目；</li><li>shared(var1,var2)：指定一个或者多个变量为多个线程的共享变量；</li><li>private(var1,var2)：指定一个变量或者多个变量在每个线程中都有它的副本；　</li><li>reduction(operator:product):指定归约操作。该子句用于指定在并行循环中进行归约操作的变量，并指定归约操作的类型，如求和、求积、求最大值等。（变量同名）（并行区里的变量是私有的）</li></ul><h3 id="运行时库函数"><a href="#运行时库函数" class="headerlink" title="运行时库函数"></a>运行时库函数</h3><p><strong>下面是一些常用的OpenMP函数：</strong></p><p>omp_get_thread_num()：返回当前线程的线程号。</p><p>omp_get_num_threads()：返回并行区域中的线程数。</p><p>omp_set_num_threads(int num_threads)：设置并行区域中的线程数。</p><p>omp_get_max_threads()：返回可用的最大线程数。</p><p>omp_get_wtime()：返回当前时间，用于计算程序的执行时间。</p><p>omp_get_num_procs()：返回系统中的处理器核心数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> num_threads=<span class="number">128</span>;</span><br><span class="line"><span class="type">long</span> num_steps=<span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> sum,pi;</span><br><span class="line">    <span class="type">double</span> step = <span class="number">1</span>/(<span class="type">double</span>)num_steps;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num_threads;i++)&#123;</span><br><span class="line">        <span class="type">double</span> start = <span class="built_in">omp_get_wtime</span>();</span><br><span class="line">        sum=<span class="number">0.0</span>;</span><br><span class="line">        pi=<span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> x;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(i) private(x) reduction(+:sum)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num_steps;j++)&#123;</span><br><span class="line">            x=step*(j+<span class="number">0.5</span>);</span><br><span class="line">            sum+=<span class="number">4</span>/(<span class="number">1</span>+ x*x);</span><br><span class="line">        &#125;</span><br><span class="line">        pi=sum*step;</span><br><span class="line">        cout&lt;&lt;pi&lt;&lt;<span class="string">&quot;   time=&quot;</span>&lt;&lt;<span class="built_in">omp_get_wtime</span>()-start&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><h2 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>MPI 全名叫 Message Passing Interface，即信息传递接口，作用是可以通过 MPI 可以在不同进程间传递消息，从而可以并行地处理任务，即进行并行计算。需要注意的是，尽管我们偶尔会说使用 MPI 编写了某某可执行程序，但是 MPI 其实只是一个库，而不是一种语言，其可以被 Fortran、C、C++、Python 调用。</p></blockquote><p>​MPI并不是多线程编程模型，而是多进程编程模型。它强调进程间的消息传递和同步，而不是共享内存。因此，MPI适用于分布式内存系统（如集群）上的并行计算，而不适用于共享内存系统（如多核处理器）上的并行计算。</p><h4 id="通讯域"><a href="#通讯域" class="headerlink" title="通讯域"></a>通讯域</h4><p>通信域定义了一组能够互相发消息的进程。在这组进程中，每个进程会被分配一个序号，称为 rank，进程间显性地通过指定 rank 作为标识来进行通信，一个进程 rank 可以指定另一个进程的 rank 以及独一无二的消息标签 tag 来发送消息。接收者也可以发送一个特定标签标记的消息的请求。类似于这样的涉及一个发送者以及一个接收者的通信被称为点对点(point-to-point)通信。</p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p><code>MPI_Init</code>是MPI库中的一个函数，它用于初始化MPI运行环境。在一个MPI程序中，通常在主函数的开始处调用<code>MPI_Init</code>函数。</p><p>函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Init</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> ***argv)</span></span></span><br></pre></td></tr></table></figure><p>参数<code>argc</code>和<code>argv</code>是主函数的参数，它们是用于命令行参数传递的。在调用<code>MPI_Init</code>之后，MPI库会解析并处理这些参数，并从中提取MPI相关的信息。这样做是为了确保MPI库能够正确地获取运行MPI程序所需的全部资源。</p><p>调用<code>MPI_Init</code>后，MPI运行环境会被初始化，MPI库将为每个MPI进程分配必要的资源，并建立MPI进程间的通信通道。每个进程都会被分配一个唯一的标识符（rank），可以通过调用<code>MPI_Comm_rank</code>函数获取自己的rank值。</p><hr><p><strong>MPI_COMM_WORLD:</strong></p><p>MPI_COMM_WORLD是MPI中的一个预定义的通信器（communicator）。它表示一个包含所有MPI进程的通信组，也就是所有进程之间的默认通信环境。</p><p>在MPI程序中，通信器（communicator）是一个抽象的概念，用于指定一组进程之间的通信关系。通信器定义了一个进程组，进程组中的进程可以相互通信。MPI提供了多种创建和使用通信器的方法，其中MPI_COMM_WORLD是最常用的一个。</p><p>MPI_COMM_WORLD通信器由MPI库在程序启动时自动创建，并且包含了运行MPI程序的所有进程。它是一个全局的通信器，可以在程序中直接使用，无需显式创建或销毁。在MPI函数中，通过指定MPI_COMM_WORLD作为通信器参数，可以将操作应用于所有进程之间的通信。</p><hr><p><code>MPI_Comm_rank</code>是MPI库中的一个函数，用于获取当前进程在指定通信器中的标识符（rank）。</p><p>函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Comm_rank</span><span class="params">(MPI_Comm comm, <span class="type">int</span> *rank)</span></span></span><br></pre></td></tr></table></figure><p>参数<code>comm</code>是一个MPI通信器，用于指定进程组的通信关系。通常可以使用<code>MPI_COMM_WORLD</code>作为通信器，表示全局的通信组。参数<code>rank</code>是一个指向整数的指针，用于存储当前进程在指定通信器中的rank值。</p><p>调用<code>MPI_Comm_rank</code>函数后，当前进程会获取指定通信器中的rank值，并将其存储在<code>rank</code>指向的变量中。rank值从0开始，表示进程在通信组中的唯一标识符。</p><hr><p><code>MPI_Comm_size</code>是MPI库中的一个函数，用于获取指定通信器中的进程总数。</p><p>函数原型如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int MPI_Comm_size(MPI_Comm comm, int *size)</span><br></pre></td></tr></table></figure><p>参数<code>comm</code>是一个MPI通信器，用于指定进程组的通信关系。通常可以使用<code>MPI_COMM_WORLD</code>作为通信器，表示全局的通信组。参数<code>size</code>是一个指向整数的指针，用于存储指定通信器中的进程总数。</p><p>调用<code>MPI_Comm_size</code>函数后，当前进程会获取指定通信器中的进程总数，并将其存储在<code>size</code>指向的变量中。</p><hr><p><code>MPI_Reduce</code>是MPI库中的一个函数，用于在通信组中进行归约操作（reduce）。归约操作将多个进程的数据进行聚合，得到一个全局的结果。</p><p>函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Reduce</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sendbuf, <span class="type">void</span> *recvbuf, <span class="type">int</span> count, MPI_Datatype datatype, MPI_Op op, <span class="type">int</span> root, MPI_Comm comm)</span></span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>sendbuf</code>：发送缓冲区的起始地址，指定了每个进程要发送的数据。</li><li><code>recvbuf</code>：接收缓冲区的起始地址，用于存储归约操作的结果。只在根进程（root）中有效。</li><li><code>count</code>：发送和接收缓冲区中的元素数量。</li><li><code>datatype</code>：数据元素的类型。</li><li><code>op</code>：归约操作的类型，例如<code>MPI_SUM</code>表示求和操作。</li><li><code>root</code>：根进程的rank值，指定了接收归约结果的进程。</li><li><code>comm</code>：通信器，用于指定通信组。</li></ul><p>调用<code>MPI_Reduce</code>函数后，在通信组中的每个进程将把自己的数据（位于<code>sendbuf</code>中）根据指定的归约操作（<code>op</code>）进行归约，最终的结果将存储在根进程的<code>recvbuf</code>中。</p><hr><p><code>MPI_Finalize</code>是MPI库中的一个函数，用于结束MPI运行环境，释放相关资源。</p><p>函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Finalize</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>调用<code>MPI_Finalize</code>函数会终止当前MPI程序的执行，并释放与MPI相关的资源。通常，<code>MPI_Finalize</code>应该在主函数的结尾处被调用。</p><hr><p><code>MPI_Send</code>是MPI库中的一个函数，用于发送消息（数据）给其他进程。</p><p>函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">int</span> count, MPI_Datatype datatype, <span class="type">int</span> dest, <span class="type">int</span> tag, MPI_Comm comm)</span></span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>buf</code>：发送缓冲区的起始地址，指定了要发送的数据。</li><li><code>count</code>：发送缓冲区中的元素数量。</li><li><code>datatype</code>：数据元素的类型。</li><li><code>dest</code>：目标进程的rank值，指定了消息的接收进程。</li><li><code>tag</code>：消息的标签，用于区分不同的消息。</li><li><code>comm</code>：通信器，用于指定通信组。</li></ul><hr><p><code>MPI_Recv</code>是MPI库中的一个函数，用于接收其他进程发送的消息（数据）。</p><p>函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Recv</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> count, MPI_Datatype datatype, <span class="type">int</span> source, <span class="type">int</span> tag, MPI_Comm comm, MPI_Status *status)</span></span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>buf</code>：接收缓冲区的起始地址，用于存储接收到的数据。</li><li><code>count</code>：接收缓冲区中的元素数量。</li><li><code>datatype</code>：数据元素的类型。</li><li><code>source</code>：源进程的rank值，指定了消息的发送进程。</li><li><code>tag</code>：消息的标签，用于区分不同的消息。</li><li><code>comm</code>：通信器，用于指定通信组。</li><li><code>status</code>：用于返回接收操作的状态信息。</li></ul><hr><p><code>MPI_Bcast</code>是MPI库中的一个函数，用于将数据广播给所有进程，使得每个进程都能接收到相同的数据。</p><p>函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Bcast</span><span class="params">(<span class="type">void</span> *buffer, <span class="type">int</span> count, MPI_Datatype datatype, <span class="type">int</span> root, MPI_Comm comm)</span></span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>buffer</code>：发送缓冲区的起始地址（对于根进程）或接收缓冲区的起始地址（对于非根进程）。</li><li><code>count</code>：缓冲区中的元素数量。</li><li><code>datatype</code>：数据元素的类型。</li><li><code>root</code>：广播操作的根进程的rank值，即广播操作的发送方。</li><li><code>comm</code>：通信器，用于指定通信组。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> rank,size;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Init</span>(&amp;argc,&amp;argv); <span class="comment">// 初始化MPI环境，创建MPI_COMM_WORLD</span></span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;rank); <span class="comment">// 获取当前进程在指定通信器中的标识符</span></span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;size); <span class="comment">// 获取指定通信器中的进程总数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rank == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;rank,<span class="number">1</span>,MPI_INT,<span class="number">1</span>,<span class="number">0</span>,MPI_COMM_WORLD); <span class="comment">// 发送数据</span></span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(&amp;n,<span class="number">1</span>,MPI_INT,<span class="number">0</span>,MPI_COMM_WORLD); <span class="comment">// 广播，对于0是发，非0是收</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(rank==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        MPI_Status status;</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(&amp;t,<span class="number">1</span>,MPI_INT,<span class="number">0</span>,<span class="number">0</span>,MPI_COMM_WORLD,&amp;status); <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;t&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">MPI_Finalize</span>(); <span class="comment">// 结束MPI环境，释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> num_steps; <span class="comment">// 步数</span></span><br><span class="line">    <span class="type">double</span> step; <span class="comment">// 步长</span></span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0.0</span>,x; </span><br><span class="line">    <span class="type">double</span> pi;</span><br><span class="line">    <span class="type">int</span> rank;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="built_in">MPI_Init</span>(&amp;argc,&amp;argv); <span class="comment">// 初始化MPI环境</span></span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;rank); <span class="comment">// 获取进程标识</span></span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;size); <span class="comment">// 获取进程数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rank==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入步数：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;num_steps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(&amp;num_steps,<span class="number">1</span>,MPI_LONG,<span class="number">0</span>,MPI_COMM_WORLD); <span class="comment">// 广播</span></span><br><span class="line">    step = <span class="number">1</span>/(<span class="type">double</span>)num_steps;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=rank;i&lt;num_steps;i+=size)&#123;</span><br><span class="line">        x=step*(i+<span class="number">0.5</span>);</span><br><span class="line">        sum+=<span class="number">4</span>/(<span class="number">1</span>+x*x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MPI_Reduce</span>(&amp;sum,&amp;pi,<span class="number">1</span>,MPI_DOUBLE,MPI_SUM,<span class="number">0</span>,MPI_COMM_WORLD); <span class="comment">// 归约</span></span><br><span class="line">    <span class="keyword">if</span>(rank==<span class="number">0</span>)&#123;</span><br><span class="line">        pi = pi*step;</span><br><span class="line">        cout&lt;&lt;pi&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MPI_Finalize</span>(); <span class="comment">// 结束MPI环境</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hadoop-and-MapReduce"><a href="#Hadoop-and-MapReduce" class="headerlink" title="Hadoop and MapReduce"></a>Hadoop and MapReduce</h2><p><a href="https://zhuanlan.zhihu.com/p/54994736">深入浅出大数据：到底什么是Hadoop？ - 知乎 (zhihu.com)</a></p><p><a href="https://juejin.cn/post/7143767067907325982">https://juejin.cn/post/7143767067907325982</a></p><h3 id="Hadoop是什么？"><a href="#Hadoop是什么？" class="headerlink" title="Hadoop是什么？"></a>Hadoop是什么？</h3><p>1）Hadoop是一个由Apache基金会所开发的<strong>分布式系统基础架构</strong>。 </p><p>2）主要解决，<strong>海量数据的存储</strong>和<strong>海量数据的分析计算</strong>问题。 </p><p>3）广义上来说，Hadoop通常是指一个更广泛的概念——Hadoop生态圈。</p><h3 id="Hadoop特点"><a href="#Hadoop特点" class="headerlink" title="Hadoop特点"></a>Hadoop特点</h3><h4 id="高可靠性"><a href="#高可靠性" class="headerlink" title="高可靠性"></a>高可靠性</h4><p>Hadoop底层维护多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失。</p><h4 id="高扩展性"><a href="#高扩展性" class="headerlink" title="高扩展性"></a>高扩展性</h4><p>在集群间分配任务数据，可方便的扩展数以千计的节点。</p><h4 id="高效性"><a href="#高效性" class="headerlink" title="高效性"></a>高效性</h4><p>在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度。</p><h4 id="高容错性"><a href="#高容错性" class="headerlink" title="高容错性"></a>高容错性</h4><p>能够自动将失败的任务重新分配。</p><h3 id="Hadoop组成"><a href="#Hadoop组成" class="headerlink" title="Hadoop组成"></a>Hadoop组成</h3><h4 id="Hadoop1-x、2-x、3-x区别"><a href="#Hadoop1-x、2-x、3-x区别" class="headerlink" title="Hadoop1.x、2.x、3.x区别"></a>Hadoop1.x、2.x、3.x区别</h4><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/695c3229db4c4c4b872a6d5733d51115~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></p><h4 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h4><p>Hadoop Distributed File System，简称 HDFS，是一个分布式文件系统。</p><p>1）<strong>NameNode（nn）</strong>：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的DataNode等。 </p><p>2）**DataNode(dn)**：在本地文件系统存储文件块数据，以及块数据的校验和。 </p><p>3）**Secondary NameNode(2nn)**：每隔一段时间对NameNode元数据备份。。</p><h4 id="YARN架构"><a href="#YARN架构" class="headerlink" title="YARN架构"></a>YARN架构</h4><p>Yet Another Resource Negotiator 简称 YARN ，另一种资源协调者，是 Hadoop 的资源管理器。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/be21fc58865e4b99b7367ea964e9ca0e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></p><h4 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h4><p>MapReduce将计算过程分为两个阶段：Map和Reduce </p><p>1）Map阶段并行处理输入数据 </p><p>2）Reduce阶段对Map结果进行汇总</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/00a793fbdfc1415597042ee79d305ca7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.creaational;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.*;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;Object,Text,Text,IntWritable&gt;&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">IntWritable</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Text</span> <span class="variable">word</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(Object key,Text value,Context context)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">            <span class="type">StringTokenizer</span> <span class="variable">tks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(value.toString());</span><br><span class="line">            <span class="keyword">while</span>(tks.hasMoreTokens())&#123;</span><br><span class="line">                word.set(tks.nextToken());</span><br><span class="line">                context.write(word,one);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntSumReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text,IntWritable,Text,IntWritable&gt;&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>();</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key,Iterable&lt;IntWritable&gt; values,Context context)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(IntWritable val : values)&#123;</span><br><span class="line">                sum += val.get();</span><br><span class="line">            &#125;</span><br><span class="line">            result.set(sum);</span><br><span class="line">            context.write(key,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Job</span>。getInstance(conf,<span class="string">&quot;word count&quot;</span>);</span><br><span class="line"></span><br><span class="line">        job.setJarByClass(WordCount.class);</span><br><span class="line">        job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">        job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">        job.setReduceClass(IntSumReducer.class);</span><br><span class="line"></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        FileInputFormat.addInputPath(job,<span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job,<span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        System.exit(job.waitComplete(<span class="literal">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Container-and-Docker"><a href="#Container-and-Docker" class="headerlink" title="Container and Docker"></a>Container and Docker</h2><ul><li>制定容器镜像格式</li><li>构建容器镜像 <code>docker build</code></li><li>管理容器镜像 <code>docker images</code></li><li>管理容器实例 <code>docker ps</code></li><li>运行容器 <code>docker run</code></li><li>实现容器镜像共享 <code>docker pull/push</code></li></ul><p><code>docker ps</code>:查看容器实例</p><p><code>docker stats</code>:查看容器资源使用情况</p><h3 id="Docker-commands"><a href="#Docker-commands" class="headerlink" title="Docker commands"></a>Docker commands</h3><table><thead><tr><th>Command</th><th>Note</th></tr></thead><tbody><tr><td>docker network ls</td><td>列出当前Docker主机上的所有网络</td></tr><tr><td>docker network inspect NETWORK_ID</td><td>检查Docker网络的详细详细信息</td></tr><tr><td>docker exec CONTAINED_NAME cat &#x2F;etc&#x2F;host</td><td>查看指定容器中，文件内容</td></tr><tr><td>docker exec -it CONTATNED_NAME &#x2F;bin&#x2F;bash</td><td>打开交互式的Bash shell</td></tr><tr><td>docker logs –details CONTAINTED_NAME</td><td>查看容器的日志信息</td></tr></tbody></table><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程复习</title>
      <link href="/posts/ishdl67348h/"/>
      <url>/posts/ishdl67348h/</url>
      
        <content type="html"><![CDATA[<h2 id="软件与软件工程介绍"><a href="#软件与软件工程介绍" class="headerlink" title="软件与软件工程介绍"></a>软件与软件工程介绍</h2><h3 id="软件的概念、特性和分类"><a href="#软件的概念、特性和分类" class="headerlink" title="软件的概念、特性和分类"></a>软件的概念、特性和分类</h3><ol><li><p><strong>软件的概念</strong>：软件是计算机系统中与硬件相互依存的另一部分，包括<strong>程序</strong>、<strong>数据</strong>及其<strong>相关文档</strong>的完整集合</p><ul><li><p><strong>程序</strong>：程序是按事先设计的功能和性能要求执行的<strong>指令序 列</strong>;</p></li><li><p><strong>数据</strong>：数据是使程序能够正确地处理信息的数据结构;</p></li><li><p><strong>相关文档</strong>：文档是与程序开发、维护和使用有关的图 文材料。</p></li></ul></li><li><p><em>软件的特性</em></p><p>形态特性、智能特性、开发特性、质量特性、生产特性、管理特性、环境特性、维护特性、废弃特性、应用特性</p></li><li><p>软件的分类</p><p>系统软件、支撑软件（工具软件）、应用软件、可复用软件</p></li></ol><h3 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h3><blockquote><p>20世纪60年代，计算机已经应用在很多行业，解决问题的规模及难度逐渐增加，由于软件本身的特点及软件开发方法等多方面问题，软件的发展速度远远滞后于硬件的发展速度，不能满足社会日益增长的软件需求。软件开发周期长、成本高、质量差、维护困难，导致20世纪60 年代末软件危机的爆发。</p></blockquote><p>除去软件本身的特点外，软件危机的原因还有以下几点：</p><ol><li>缺乏软件开发的经验和有关软件开发数据的积累，使得开发工作的计划很难制定。</li><li>软件人员与用户的交流存在障碍，除了知识背景的差异，缺少合适的交流方法及需求描述工具也是一个重要的原因。</li><li>软件开发过程不规范，缺少方法论和规范的指导，开发人员各自为战。</li><li>随着软件规模的增大，其复杂性往往会呈指数级升高。</li><li>缺少有效的软件评测手段，提交用户的软件质量差。</li></ol><h3 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h3><blockquote><p>为了克服软件危机，1968年10月在北大西洋公约组织（NATO）召开的计算机科学会议上，Fritz Bauer首次提出“软件工程”的概念，试图将工程化方法应用于软件开发。</p><p>许多计算机和软件科学家尝试，把其他工程领域中行之有效的工程学知识运用到软件开发工作中来。经过不断实践和总结，最后得出一个结论:按工程化的原则和方法组织软件开发工作是有效的，是摆脱软件危机的一条主要的出路。</p><p>我国2006 年的国家标准GB&#x2F;T11457—2006《软件工程术语》中对软件工程的定义为: “<strong>应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的 软件产品的定义、开发、发布和维护的工程或进行研究的学科。</strong>”</p></blockquote><p><em>概括地说，<strong>软件工程</strong>是指导软件<strong>开发</strong>和<strong>维护</strong>的工程性学科，主要思想在于强调在软件开发过程中应用工程化原则的重要性。</em></p><ol><li><strong>软件工程的目标</strong><ol><li><strong>软件的质量特性</strong>：功能性、可靠性、易用性、效率、维护性和可移植性。</li><li><strong>软件工程的目标</strong>是运用先进的<strong>软件开发技术</strong>和<strong>管理方法</strong>来提高<strong>软件的质量和生产率</strong>,也就是要以较短的周期、较低的成本生产出高质量的软件产品，并最终实现软件的工业化生产。</li></ol></li><li>软件工程的基本原理<ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组的人员应该少而精</li><li>承认不断改进软件工程实践的必要性</li></ul></li></ol><h3 id="软件生存期"><a href="#软件生存期" class="headerlink" title="软件生存期"></a>软件生存期</h3><p><strong>概念：</strong></p><blockquote><p>软件也有一个孕育、诞生、成长、成熟和衰亡的生存过程，我们称这个过程为<strong>软件生命周期</strong>或<strong>软件生存期</strong>。</p></blockquote><p><strong>软件生存期</strong>又称软件生命周期，由<strong>软件定义</strong>、<strong>软件开发</strong>、<strong>运行维护</strong>三个时期组成。</p><ul><li><strong>软件定义时期</strong>的主要任务是解决“做什么”的问题。</li><li><strong>软件开发时期</strong>的主要任务是解决“如何做”的问题。</li><li><strong>运行维护时期</strong>的主要任务是使软件持久地满足用户的需要。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">  subgraph  </span><br><span class="line">    软件生命周期 --&gt; 软件定义</span><br><span class="line">    subgraph  </span><br><span class="line">    软件定义 --&gt; 问题定义</span><br><span class="line">    软件定义 --&gt; 可行性研究</span><br><span class="line">    软件定义 --&gt; 需求分析</span><br><span class="line">    end</span><br><span class="line">    软件生命周期 --&gt; 软件开发</span><br><span class="line">    subgraph  </span><br><span class="line">    软件开发 --&gt; 概要设计</span><br><span class="line">    软件开发 --&gt; 详细设计</span><br><span class="line">    软件开发 --&gt; 编码</span><br><span class="line">    软件开发 --&gt; 测试</span><br><span class="line">    end</span><br><span class="line">    软件生命周期 --&gt; 运行维护</span><br><span class="line">    subgraph  </span><br><span class="line">    运行维护 --&gt; 改正性维护</span><br><span class="line">    运行维护 --&gt; 适应性维护</span><br><span class="line">    运行维护 --&gt; 完善性维护</span><br><span class="line">    运行维护 --&gt; 预防性维护</span><br><span class="line">    end</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p><strong>各阶段耗时比例：</strong></p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226210241938.png" alt="image-20231226210241938" style="zoom:40%;" /><h4 id="软件定义"><a href="#软件定义" class="headerlink" title="软件定义"></a>软件定义</h4><h5 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h5><ul><li><p>关键问题是：“<strong>要解决的问题是什么</strong>”。</p></li><li><p>提交的内容为关于问题性质、工程目标和工程规模的书面报告。</p></li></ul><h5 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h5><ul><li><p>回答的关键问题是：“<strong>上一个阶段所确定的问题是否有行得通的解决办法</strong>”。</p></li><li><p>提交的内容为可行性研究报告，即从技术、经济和社会因素等方面研究各方案的可行性。</p></li></ul><h5 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h5><ul><li><p>对用户提出的要求进行分析并给出详细的定义。</p></li><li><p>准确地回答“<strong>目标系统必须做什么</strong>”这个问题。也就是对目标系统提出完整、准确、清晰、具体的要求。</p></li><li><p>编写<strong>软件需求说明书</strong>或<strong>系统功能说明书</strong>及<strong>初步的系统用户手册</strong>。</p></li><li><p>提交管理机构<strong>评审</strong>。</p></li></ul><h4 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h4><ul><li><strong>任务</strong>：具体设计和实现前一个时期即软件定义时期定义的软件。</li><li><strong>执行人</strong>：系统设计员，高级程序员，程序员，测试工程师和辅助人员等</li><li><strong>阶段划分</strong>：分为概要设计、详细设计、编码和单元测试、集成测试和系统测试。其中前两个阶段又称为系统设计，后两个阶段又称为系统实现。</li></ul><h5 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h5><ul><li><p>概括地回答“怎样实现目标系统?”。</p></li><li><p>设计程序的体系结构，也就是确定程序由哪些模块组成以及模块间的关系。</p></li><li><p>提交的文档是概要设计说明书。</p></li></ul><h5 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h5><ul><li><p>回答“应该怎样具体地实现这个系统”。</p></li><li><p>详细地设计每个模块，确定实现模块功能所需要的算法和数据结构。</p></li><li><p>提交的文档是软件的详细设计说明书。</p></li></ul><h5 id="程序编码和单元测试"><a href="#程序编码和单元测试" class="headerlink" title="程序编码和单元测试"></a>程序编码和单元测试</h5><ul><li><p>写出正确的容易理解、容易维护的程序模块。</p></li><li><p>提交的文档为源程序、详尽的程序说明和单元测试报告。</p></li></ul><h5 id="集成测试和系统测试"><a href="#集成测试和系统测试" class="headerlink" title="集成测试和系统测试"></a>集成测试和系统测试</h5><ul><li><p>通过各种类型的测试(及相应的调试)使软件达到预定的要求。</p></li><li><p>提交的文档为测试计划、详细测试方案以及实际测试结果等。</p></li></ul><h4 id="运行维护"><a href="#运行维护" class="headerlink" title="运行维护"></a>运行维护</h4><p>主要任务是使软件<strong>持久地</strong>满足用户的需要，通常有4类维护活动：</p><ul><li><p><strong>改正性维护</strong>，也就是诊断和改正在使用过程中发现的软件错误；</p></li><li><p><strong>适应性维护</strong>，即修改软件以适应环境的变化；</p></li><li><p><strong>完善性维护</strong>，即根据用户的要求改进或扩充软件，使它更完善；</p></li><li><p><strong>预防性维护</strong>，即修改软件为将来的维护活动预先做准备。</p></li></ul><h4 id="典型文档"><a href="#典型文档" class="headerlink" title="典型文档"></a>典型文档</h4><ul><li><p><strong>软件需求规格说明书</strong>：描述将要开发的软件做什么。</p></li><li><p><strong>项目计划</strong>：描述将要完成的任务及其顺序，并估计所需要的时间及工作量。</p></li><li><p><strong>软件测试计划</strong>：描述如何测试软件，使之确保软件应实现规定的功能，并达到预期的性能。</p></li><li><p><strong>软件设计说明书</strong>：描述软件的结构，包括概要设计及详细设计。</p></li><li><p><strong>用户手册</strong>：描述如何使用软件。</p></li></ul><h3 id="软件工程化方法概论"><a href="#软件工程化方法概论" class="headerlink" title="软件工程化方法概论"></a><strong>软件工程化方法概论</strong></h3><blockquote><p>通常把软件开发生命周期全过程中使用的一整套技术的集合称为方法学（methodology)，也称为范型（paradigm)。在软件工程范畴中，这两个词的含义基本相同。</p></blockquote><p><strong>软件工程方法学</strong>包含三个要素:<strong>方法</strong>、<strong>工具</strong>和<strong>过程</strong>。</p><ul><li><strong>软件工程方法（method）</strong>为建造软件提供技术上的解决方法（“如何做”）。目前使用得最广泛的方法是传统方法（结构化方法）和面向对象的方法。</li><li><strong>工具</strong>为方法的运用提供自动的或半自动的软件支撑环境，如CASE（Computer Aided Soft-ware Engineering)工程</li><li><strong>过程</strong>是获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤</li></ul><h2 id="软件生存期模型"><a href="#软件生存期模型" class="headerlink" title="软件生存期模型"></a>软件生存期模型</h2><h3 id="瀑布模型（文档驱动）"><a href="#瀑布模型（文档驱动）" class="headerlink" title="瀑布模型（文档驱动）"></a>瀑布模型（文档驱动）</h3><h4 id="传统的瀑布模型"><a href="#传统的瀑布模型" class="headerlink" title="传统的瀑布模型"></a>传统的瀑布模型</h4><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226211944358.png" alt="image-20231226211944358" style="zoom:40%;" /><p><strong>特点</strong></p><ol><li><strong>阶段间具有顺序性和依赖性</strong>。其中包含两重含义：<ol><li>必须等前一阶段的工作完成之后，才能开始后一阶段的工作</li><li>前一阶段的输出文档就是后一阶段的输入文档</li></ol></li><li><strong>推迟实现</strong>的观点：<ol><li>瀑布模型在编码之前设置了系统分析和系统设计的各个阶段，分析与设计阶段的基本任务规定，在这两个阶段主要考虑目标系统的逻辑模型，不涉及软件的物理实现。</li><li>清楚地区分逻辑设计与物理设计，尽可能推迟程序的物理实现，是按照瀑布模型开发软件的一条重要的指导思想。</li></ol></li><li><strong>质量保证</strong>的观点：<ol><li>每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。</li><li>每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误。</li></ol></li></ol><h4 id="实际的瀑布模型"><a href="#实际的瀑布模型" class="headerlink" title="实际的瀑布模型"></a>实际的瀑布模型</h4><ul><li><p>实际的瀑布模型是“反馈环”的，如图所示。</p></li><li><p>图中实线箭头表示开发过程，虚线箭头表示维护过程。</p></li></ul><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226212540631.png" alt="image-20231226212540631" style="zoom:40%;" /><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>可强迫开发人员采用规范化的方法。</p></li><li><p>严格地规定了每个阶段必须提交的文档。</p></li><li><p>要求每个阶段交出的所有产品都必须是经过验证的。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要。如果需求规格说明与用户需求之间有差异，就会发生这种情况。</p></li><li><p>瀑布模型只适用于项目开始时需求已确定的情况。</p></li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>需求明确、较大型系统、开发周期不紧张</li></ul><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><blockquote><p>快速原型是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。</p></blockquote><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226214218092.png" alt="image-20231226214218092" style="zoom:40%;" /><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>探索型原型</strong></p><blockquote><p>这种类型的原型是把原型用于开发的需求分析阶段，目的是要型清用户的需求，确定所期望的特性，并探索各种方案的可行性。它主要针对开发目标模糊，用户与开发都对项目都缺乏经验的情况，通过对原型的开发来明确用户的需求。</p></blockquote><p><strong>实验型原型</strong></p><blockquote><p>这种原型主要用于设计阶段，考核；实现方案是否合适，能否实陋。对于一个大型系统，若对设计方案心中没有把握时，可通过这种原型来证实设计方案的正确性</p></blockquote><p><strong>演化型原型</strong></p><blockquote><p>这种原型主要用于及早向用户提交一个原型系统，该原型系统或者包含系统的框架，或者包含系统的主要功能，在得到用户的认可后，将原型系统不断扩充演变为最终的软件系统。它将原型的思想扩展到软件开发的全过程。</p></blockquote><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li><p>有助于满足用户的真实需求。</p></li><li><p>原型系统已经通过与用户的交互而得到验证，据此产生的规格说明文档能够正确地描述用户需求。</p></li><li><p>软件产品的开发基本上是按线性顺序进行。</p></li><li><p>因为规格说明文档正确地描述了用户需求，因此，在开发过程的后续阶段不会因为发现规格说明文档的错误而进行较大的返工。</p></li><li><p>开发人员通过建立原型系统已经学到了许多东西，因此，在设计和编码阶段发生错误的可能性也比较小，这自然减少了在后续阶段需要改正前面阶段所犯错误的可能性。</p></li><li><p>快速原型的突出特点是“快速”。开发人员应该尽可能快地建造出原型系统，以加速软件开发过程，节约软件开发成本。</p></li></ul><p>​<strong>原型的用途是获知用户的真正需求，一旦需求确定了，原型可以抛弃，当然也可以在原型的基础上进行开发。</strong></p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>准确原型设计困难</li><li>原型理解可能不同</li><li>不利于开发人员创新</li></ul><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><ul><li><p>增量模型也称为渐增模型，是Mills等于1980年提出来的。</p></li><li><p>使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。</p></li><li><p>每个构件由多个相互作用的模块构成，并且能够完成特定的功能。</p></li></ul><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226214519036.png" alt="image-20231226214519036" style="zoom:40%;" /><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>能在较短时间内向用户提交可完成一些有用的工作产品，即从第1个构件交付之日起，用户就能做一些有用的工作。</li><li>逐步增加产品的功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给用户组织带来的冲击。</li><li>项目失败的风险较低，虽然在某些增量构件中可能遇到一些问题，但其他增量构件将能够成功地交付给客户。</li><li>优先级最高的服务首先交付，然后再将其他增量构件逐次集成进来。因此，最重要的系统服务将接受最多的测试。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>增量构件划分以及集成困难</li><li>容易退化为边做边改模型</li></ul><h3 id="螺旋模型（风险驱动）"><a href="#螺旋模型（风险驱动）" class="headerlink" title="螺旋模型（风险驱动）"></a>螺旋模型（风险驱动）</h3><blockquote><p>在每个阶段之前都增加了风险分析过程的快速原型模型</p></blockquote><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227205233935.png" alt="image-20231227205233935" style="zoom:50%;" /><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul><li>利于把软件质量作为软件的开发目标</li><li>减少测试</li><li>维护和开发不分开</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li>风险估计困难</li></ul><h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><h3 id="敏捷开发方法与极限编程"><a href="#敏捷开发方法与极限编程" class="headerlink" title="敏捷开发方法与极限编程"></a>敏捷开发方法与极限编程</h3><p><strong>敏捷开发：</strong></p><ul><li>强调人与人之间的沟通。</li><li>轻文档（弱化文档，但不是不需要文档）</li><li>客户需要全程参与</li><li>需求可以的变化</li></ul><p><strong>极限编程（Extreme Programming，XP）：</strong></p><ol><li>用户故事（User Stories）：以用户的视角描述软件功能和需求。</li><li>迭代开发：将开发过程划分为短小的迭代周期，并在每个周期内交付可用的软件。</li><li>快速反馈：通过频繁的客户反馈和自动化测试，及早发现和解决问题。</li><li>集体所有权（Collective Ownership）：团队成员共同拥有代码和系统，鼓励共同协作和责任。</li><li>持续集成（Continuous Integration）：团队成员频繁地将代码集成到共享代码库中，并进行自动化测试和构建。</li><li>可持续性（Sustainability）：注重团队成员的健康、工作量的平衡和可持续的开发节奏。</li></ol><h4 id="敏捷原则"><a href="#敏捷原则" class="headerlink" title="敏捷原则"></a>敏捷原则</h4><p>(1)我们最优先要做的是通过尽早、持续交付有价值的软件来使客户满意。</p><p>(2)即使在开发的后期，也欢迎需求变更。敏捷过程利用变更为客户创造竞争优势。</p><p>(3)经常交付可运行软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。</p><p>(4)在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。 </p><p>(5)围绕有积极性的个人构建项目。给他们提供所需的环境和支持，并且信任他们能够完成工作。</p><p>(6)在团队内部，最富有效果和效率的信息传递方法是面对面交谈。</p><p>(7)可运行软件是进度的首要度量标准。</p><p>(8)敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够保持一种长期、稳定的开发速度。</p><p>(9)不断地关注优秀的技能和好的设计会增强敏捷能力。</p><p>(10)简单是必要的。</p><p>(11)好的架构、需求和设计出自于自组织团队。</p><p>(12)每隔一定时间，团队会反省如何才能更有效地工作，并相应调整自己的行为。</p><h3 id="CMM-CMMI"><a href="#CMM-CMMI" class="headerlink" title="CMM&#x2F;CMMI"></a>CMM&#x2F;CMMI</h3><h4 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h4><blockquote><p>CMM（Capability Maturity Model for Software）软件能力成熟度模型。</p></blockquote><p>　　<strong>1.初始级(initial)</strong></p><p>　　工作无序，项目进行过程中常放弃当初的规划</p><p>　　管理无章，缺乏健全的管理制度</p><p>　　开发项目的成效不稳定，产品的性能和质量依赖于个人能力和行为。</p><p>　　<strong>2.可重复级(Repeatable)</strong></p><p>　　管理制度化，建立了基本的管理制度和规程，管理工作有章可循</p><p>　　初步实现标准化，开发工作较好的实施标准</p><p>　　稳定课跟踪，新项目的计划和管理基于过去的实践经验，具有重复以前成功项目的环境和条件</p><p>　　<strong>3.已定义级(Defined)</strong></p><p>　　开发的过程，包括技术工作和管理工作，均已实现标准化，文档化。</p><p>　　建立了完善的培训制度和专家评审制度</p><p>　　全部技术活动和管理活动均可稳定实施</p><p>　　项目的质量，进度和费用均可控制。</p><p>　　对项目进行中的过程，岗位和指责均有共同的理解。</p><p>　　<strong>4.已管理级(Managed)</strong></p><p>　　产品和过程已建立了定量的质量目标。</p><p>　　过程中活动的生产率和质量是可度量的。</p><p>　　已建立过程数据库。</p><p>　　已实现项目产品和过程的控制</p><p>　　可预测过程和产品质量趋势。</p><p>　　<strong>5.优化级(Optimizing)</strong></p><p>　　可集中精力改进过程，采用新技术，新方法。</p><p>　　拥有防止出现缺陷，识别薄弱环节以及加以改进的手段</p><p>　　可取得过程有效性的统计数据，并可据此进行分析，从而得到更佳方法。</p><h4 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h4><p>CMMI（Capability Maturity Model Integration）软件成熟度模型集成。CMMI是CMM模型的最新版本。</p><p>CMMI认证一共有5个级别，CMMI1级，初始级；CMMI2级，已管理级；CMMI3级，已定义级；CMMI4级，已量化管理级；CMMI5级，优化级</p><h2 id="软件需求获取与结构化分析"><a href="#软件需求获取与结构化分析" class="headerlink" title="软件需求获取与结构化分析"></a>软件需求获取与结构化分析</h2><h3 id="需求获取的任务和原则"><a href="#需求获取的任务和原则" class="headerlink" title="需求获取的任务和原则"></a>需求获取的任务和原则</h3><p><strong>需求获取的任务</strong></p><ol><li>发现和分析问题，并分析问题的原因&#x2F;结果关系。</li><li>与用户进行各种方式的交流，并使用调查研究方法收集信息。</li><li>按照三个成分观察问题的不同侧面、即数据、过程和接口</li><li>将获取的需求文档化，形式有用例、决策表、需求表等</li></ol><p><strong>需求获取的原则</strong></p><ol><li><strong>深入浅出的原则。</strong>就是说，需求获取要尽可能全面、细致。获取的需求是个全集，目标系统真正实现的是个子集。</li><li><strong>以流程为主线的原则。</strong>在与用户交流的过程中，应该用流程将所有的内容串起来。如信息、组织结构、处理规则等。这样便于交流沟通。流程的描述既有宏观描述，也有微观描述。</li></ol><hr><p>可以把软件需求分析阶段的工作分为4个步骤，即<strong>获取需求</strong>、<strong>分析需求</strong>、<strong>定义需求</strong>和<strong>验证需求</strong>。</p><ol><li><p><strong>需求获取</strong></p><p>通过启发、引导从客户（或用户）那里得到的原始需求是他们的业务要求（needs），简称为N。这是分析之前获取的需求，其中可能存在一些实际问题，这些问题只有通过分析才能得到解决，直接把获取的需求作为软件设计阶段的依据将会导致严重的后果。 </p></li><li><p><strong>分析需求</strong></p><p>认真研究获取的需求，必须考虑以下几方面：<br>   (1) <strong>完整性</strong>：每项获取的需求都应给出清楚的描述，使得软件开发工作能够取得设计和实现该功能所需要的全部必要信息。<br>   (2) <strong>正确性</strong>：获取的每项需求必须是准确无误的，并且需求描述无歧义性。<br>   (3) <strong>合理性</strong>：各项需求之间、软件需求与系统需求之间应是协调一致的，不应存在矛盾和冲突。</p><p>   (4) <strong>可行性</strong>：包括技术可行性 、经济可行性 、社会可行性 。<br>   (5) <strong>充分性</strong>：获取的需求是否全面、周到。 </p><p>由于分析的过程会对获取的需求做部分调整，也即从获取的需求N中去掉了一些a，又补充了一些c，从而得到的是分析的需求R1（b+c）。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231229103820903.png" alt="image-20231229103820903"></p></li><li><p><strong>定义需求</strong></p><p>​    将已经过分析的需求清晰、全面、系统、准确地描述成为正式的文档，这一步定义需求的工作就是编写需求规格说明。 </p></li><li><p><strong>验证需求</strong></p><p>为了确保已定义的需求（需求规格说明）准确无误，并能为客户（或用户）理解和接受，需要对其进行严格的评审。</p></li></ol><hr><h3 id="结构化分析方法"><a href="#结构化分析方法" class="headerlink" title="结构化分析方法"></a>结构化分析方法</h3><blockquote><p>传统的分析建模方法称为结构化分析（structured analysis，SA）方法。</p></blockquote><p>结构化分析方法是一种建模技术，它建立的分析模型如图所示。</p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231229104334213.png" alt="image-20231229104334213" style="zoom: 70%;" /><p>该模型的核心是数据字典，包括在目标系统中所使用和生成的所有数据对象。围绕这个核心有三种图</p><ol><li><strong>数据流图（DFD）</strong>：描述数据在系统中如何被传送或变换，以及描述如何对数据流进行变换的功能（子功能），用于功能建模。</li><li><strong>实体-关系图（ER图）</strong>：描述数据对象及数据对象之间的关系，用于数据建模。</li><li><strong>状态-迁移图（STD）</strong>：描述系统对外部事件如何响应、如何动作，用于行为建模。</li></ol><h4 id="功能建模"><a href="#功能建模" class="headerlink" title="功能建模"></a>功能建模</h4><blockquote><p> 功能建模的思想就是用抽象模型的概念，按照软件内部数据传递、变换的关系，自顶向下逐层分解，直到找到满足功能要求的所有可实现的软件为止。功能模型用数据流图来描述。</p></blockquote><ol><li><p>数据流图的基本图形符号</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20230912161513724.png" alt="image-20230912161513724"></p><p>多个数据流之间的关系</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20230912161752810.png" alt="image-20230912161752810"></p></li><li><p>环境图</p><blockquote><p>环境图（context diagram）也称为顶层数据流图（或0层数据流图)，它仅包括一个数据处理过程，也就是要开发的目标系统。环境图的作用是确定系统在其环境中的位置，通过确定系统的输人和输出与外部实体的关系确定其边界。</p></blockquote><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20230912161909164.png" alt="image-20230912161909164"></p></li><li><p>数据流图的分层</p><blockquote><p>稍为复杂一些的实际问题，在数据流图上常常出现十几个甚至几十个加工。这样的数据 ，流图看起来不直观，不易理解。分层的数据流图能很好地解决这一向题。按照系统的层次结结构进行逐步分解，并以分层的数据流图反映这种结构关系，能清楚地表达整个系统，也容易 理解。</p></blockquote></li></ol><h4 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h4><ul><li>在结构化分析方法中，使用实体—关系建模技术来建立数据模型。</li><li>这种技术是在较高的抽象层次（概念层）上对数据库结构进行建模的流行技术。</li><li>实体—关系模型表示为可视化的实体—关系图（entity-relationship diagram，ERD），也称为ER图。 </li><li>ER图中仅包含3种相互关联的元素：<strong>数据对象（实体）</strong>、描述数据对象的<strong>属性</strong>及数据对象彼此间相互连接的<strong>关系</strong>。</li></ul><h5 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h5><ul><li><p>数据对象是目标系统所需要的复合信息的表示，所谓复合信息是具有若干不同属性的信息。在<strong>ER</strong>图中用矩形表示数据对象。</p></li><li><p>在实际问题中，数据对象（实体）可以是外部实体、事物、角色、行为或事件、组织单位、地点或结构等。</p></li></ul><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li><p>属性定义数据对象的特征，如数据对象学生的学号、姓名、性别、专业等，课程的课程编号、课程名称、学分等。</p></li><li><p>在<strong>ER</strong>图中用椭圆或圆角矩形表示属性，并用无向边将属性与相关的数据对象连接在一起</p></li></ul><h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><ul><li><p>不同数据对象的实例之间是有关联关系的，在<strong>ER</strong>图上用<strong>无向边</strong>表示。</p></li><li><p>在无向边的两端应标识出关联实例的数量，也称为关联的<strong>重数</strong>。</p></li><li><p>从关联重数的角度可以将关联分为３种。</p></li></ul><p><strong>(1)</strong> 一对一（<strong>1:1</strong>）关联</p><p><strong>(2)</strong> 一对多（<strong>1:m</strong>）关联</p><p><strong>(3)</strong> 多对多（<strong>m:n</strong>）关联</p><ul><li>实例关联还有“必须”和“可选”之分。</li></ul><p>​在ER图中用圆圈表示所关联的实例是可选的，隐含表示“0”，没有出现圆圈就意味着是必须的。出现在连线上的短竖线可以看成是“1”。 </p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231229140200301.png" alt="image-20231229140200301"></p><h4 id="行为建模"><a href="#行为建模" class="headerlink" title="行为建模"></a>行为建模</h4><blockquote><p>状态转换图（简称状态图）通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。状态图中使用的主要符号如图所示。</p></blockquote><p><img src="C:\Users\胡华裕\AppData\Roaming\Typora\typora-user-images\image-20231229140308010.png" alt="image-20231229140308010"></p><p><strong>状态的表示：</strong>初态用<strong>实心圆</strong>表示，终态用<strong>牛眼图</strong>形表示，中间态用<strong>圆角矩形</strong>表示。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231229140546665.png" alt="image-20231229140546665"></p><p>决策表</p><p>决策树</p><h2 id="结构化设计方法"><a href="#结构化设计方法" class="headerlink" title="结构化设计方法"></a>结构化设计方法</h2><h3 id="软件设计的概念与原则"><a href="#软件设计的概念与原则" class="headerlink" title="软件设计的概念与原则"></a>软件设计的概念与原则</h3><h4 id="软件设计的原则"><a href="#软件设计的原则" class="headerlink" title="软件设计的原则"></a>软件设计的原则</h4><h5 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h5><h5 id="模块独立性"><a href="#模块独立性" class="headerlink" title="模块独立性"></a>模块独立性</h5><p><strong>模块独立性的度量准则</strong></p><ul><li>**耦合:**是模块之间的互相连接的紧密程度的度量。</li><li>**内聚:**是模块功能强度(一个模块内部各个元素彼此结合的紧密程度)的度量。</li><li>模块独立性比较强的模块应是高内聚低耦合的模块。</li></ul><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231229143221598.png" alt="image-20231229143221598" style="zoom:50%;" /><p><strong>非直接耦合（Nondirect Coupling）</strong></p><ul><li>两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。</li><li>非直接耦合的模块独立性最强。</li></ul><p><strong>数据耦合（Data Coupling）</strong></p><p>​一个模块访问另一个模型时，彼此之间是通过简单数据参数（不是控制参数、公共数据结构或外部变量）来交换输入、输出信息的。也是比较理想的耦合。</p><p><strong>特征耦合（Stamp Coupling）</strong></p><p>一组模块通过参数表传递记录信息，就是特征耦合。这个记录是某一数据结构的子结构，而不是简单变量。</p><p><strong>控制耦合（Control Coupling）</strong></p><p>如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。</p><p><strong>公共耦合（Common Coupling）</strong></p><p>若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。</p><p><strong>内容耦合（Content Coupling）</strong></p><ul><li>一个模块直接访问另一个模块的内部数据</li><li>一个模块不通过正常入口转到另一模块内部。</li><li>两个模块有一部分程序代码重迭。(只可能出现在汇编语言中)。</li><li>一个模块有多个入口。</li></ul><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230090303481.png" alt="image-20231230090303481"></p><p><strong>偶然内聚（Coincidental COhesion）</strong></p><p>当模块内各部分之间没有联系，或者即使有联系，这种联系也很松散，则称这种模块为偶然内聚模块，内聚程度最低。</p><p><strong>逻辑内聚（Logical Cohesion）</strong></p><p>把几种相关的功能组合在一起，每次被调用时，由传送给模块的判定参数来确定该模块应执行哪个功能。</p><p><strong>时间内聚（Classical Cohesion）</strong></p><p>时间内聚模块大多为多功能模块，但模块的各个功能的执行与时间有关，通常要求所有功能必须在同一时间段内执行。</p><p><strong>过程内聚（Procedural Cohesion）</strong></p><p>如果一个模块内的处理是相关的，而且必须以特定次序执行，则是过程内聚。</p><p><strong>顺序内聚</strong></p><p>一个模块中的处理元素和同一功能密切相关，而且这些处理必须顺序执行，则称为顺序内聚。</p><p><strong>功能内聚 (Functional Cohesion)</strong></p><p>一个模块中各个部分都是完成某一具体功能必不可少的组成部分，或者说该模块中所有部分都是为了完成一项具体功能而协同工作，紧密联系，不可分割的。则称该模块为功能内聚模块。</p><h5 id="提高抽象层次"><a href="#提高抽象层次" class="headerlink" title="提高抽象层次"></a>提高抽象层次</h5><ul><li>抽象是指忽视一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。</li><li>当我们进行软件设计时，设计开始时应尽量提高软件的抽象层次，按抽象级别从高到低进行软件设计。</li></ul><h5 id="复用性设计"><a href="#复用性设计" class="headerlink" title="复用性设计"></a>复用性设计</h5><ul><li>复用是指同一事物不做修改或稍加修改就可以多次重复使用。将复用的思想用于软件开发，称为软件复用。</li><li>我们将软件的重用部分称为软构件。</li><li>也就是说，在构造新的软件系统时不必从零做起，可以直接使用已有的软构件即可组装（或加以合理修改）成新的系统。</li></ul><h5 id="灵活性设计"><a href="#灵活性设计" class="headerlink" title="灵活性设计"></a>灵活性设计</h5><h3 id="结构化设计"><a href="#结构化设计" class="headerlink" title="结构化设计"></a>结构化设计</h3><h4 id="软件设计的任务"><a href="#软件设计的任务" class="headerlink" title="软件设计的任务"></a>软件设计的任务</h4><ul><li>从工程管理的角度，可以将软件设计分为<strong>概要设计阶段</strong>和<strong>详细设计阶段</strong>。</li><li>从技术的角度，传统的结构化方法将软件设计划分为体系结构设计、数据设计、接口设计和过程设计4部分；</li><li>面向对象方法则将软件设计划分为体系结构设计、类设计&#x2F;数据设计、接口设计和构件级设计4部分。</li></ul><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230091024955.png" alt="image-20231230091024955"></p><ul><li><p><strong>体系结构设计：</strong>体系结构设计定义软件的主要结构元素及其之间的关系。</p></li><li><p><strong>接口设计</strong>：接口设计描述用户界面，软件和其他硬件设备、其他软件系统及使用人员的外部接口，以及各种构件之间的内部接口。</p></li><li><p><strong>数据设计：</strong>传统方法主要根据需求阶段所建立的实体—关系图（ER图）来确定软件涉及的文件系统的结构及数据库的表结构。 </p></li><li><p><strong>过程设计：</strong>过程设计的主要工作是确定软件各个组成部分内的算法及内部数据结构，并选定某种过程的表达形式来描述各种算法。</p></li></ul><h3 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h3><h4 id="基于数据流方法的设计过程"><a href="#基于数据流方法的设计过程" class="headerlink" title="基于数据流方法的设计过程"></a>基于数据流方法的设计过程</h4><p>…</p><h3 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h3><h4 id="标志符号"><a href="#标志符号" class="headerlink" title="标志符号"></a>标志符号</h4><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102154451072.png" alt="image-20240102154451072"></p><h4 id="McCabe度量法"><a href="#McCabe度量法" class="headerlink" title="McCabe度量法"></a>McCabe度量法</h4><p>环路复杂度：</p><p>V（G）&#x3D; E - N + 2</p><p>E：边数</p><p>N：顶点数</p><h2 id="面向对象方法与UML"><a href="#面向对象方法与UML" class="headerlink" title="面向对象方法与UML"></a>面向对象方法与UML</h2><blockquote><p>面向对象＝对象＋类＋继承＋消息通信</p></blockquote><h3 id="UML简介"><a href="#UML简介" class="headerlink" title="UML简介"></a>UML简介</h3><p><strong>面向对象的建模语言</strong>很多，目前使用最广泛的是统一建模语言(UML，Unified Modeling Language)；</p><p><strong>特点：</strong></p><ol><li><p><strong>统一标准</strong></p><p>UML不仅统一了Booch、OMT和OOSE等方法中的基本概念，还吸取了面向对象技术领域中其他流派的长处，其中也包括非OO方法的影响。已经成为OMG的标准。  </p></li><li><p><strong>面向对象</strong></p><p>   UML支持面向对象技术的主要概念，它提供了一批基本的表示模型元素的图形和方法，能简洁明了地表达面向对象的各种概念和模型元素。</p></li><li><p><strong>可视化，表达能力强</strong></p><p>UML是一种图形化语言，用UML的模型图形能清晰地表示系统的逻辑模型或实现模型。UML还提供了语言的扩展机制，用户可以根据需要增加定义自己的构造型、标记值和约束等。 </p></li><li><p><strong>独立于过程</strong></p><p>UML是系统建模的语言，不依赖特定的开发过程。</p></li><li><p><strong>易于掌握使用</strong></p><p>UML概念明确，建模表示法简洁明了，图形结构清晰，容易掌握使用。</p></li></ol><h3 id="UML基本模型"><a href="#UML基本模型" class="headerlink" title="UML基本模型"></a>UML基本模型</h3><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230100856738.png" alt="image-20231230100856738" style="zoom:80%;" /><h3 id="UML的事物"><a href="#UML的事物" class="headerlink" title="UML的事物"></a>UML的事物</h3><ul><li>事物是对模型中最具代表性成分的抽象，在UML中，可以分为<strong>结构事物、行为事物、分组事物</strong>和<strong>注释事物</strong>4类。</li></ul><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230104253226.png" alt="image-20231230104253226"></p><h4 id="结构事物"><a href="#结构事物" class="headerlink" title="结构事物"></a>结构事物</h4><ul><li>结构事物是UML模型的<strong>静态部分</strong>，主要用来描述概念的或物理的元素，包括类、主动类、接口、对象、用例、参与者、协作、构件和节点等。</li></ul><ol><li><p>类（class）── 类用带有类名、属性和操作的矩形框来表示。</p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101422858.png" alt="image-20231230101422858" style="zoom: 50%;" /><p><strong>可见性：</strong></p><p>+: public</p><p>-: private</p><p>#: protected</p><p>~: package&#x2F;default</p></li><li><p>主动类（active class）── 主动类的实例应具有一个或多个进程或线程，能够启动控制活动。</p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101541517.png" alt="image-20231230101541517" style="zoom:50%;" /></li><li><p>接口（interface）── 描述了一个类或构件的一组外部可用的服务（操作）集。</p><p>接口定义的是一组操作的描述，而不是操作的实现。一般将接口画成从实现它的类或构件引出的圆圈，接口体现了使用与实现分离的原则。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101707479.png" alt="image-20231230101707479"></p></li><li><p>对象（object）── 对象是类的实例，其名字下边加下划线，对象的属性值需明确给出。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101853215.png" alt="image-20231230101853215"></p></li><li><p>用例（use case）── 也称用况，用于表示系统想要实现的<strong>行为</strong>，即描述<strong>一组动作序列</strong>（即场景）。而系统执行这组动作后将产生一个对特定参与者有价值的结果。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101921330.png" alt="image-20231230101921330"></p></li><li><p>参与者（actor）── 也称角色，是指与系统有信息交互关系的人、软件系统或硬件设备，在图形上用简化的小木头人表示。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101948468.png" alt="image-20231230101948468"></p></li><li><p>协作（collaboration）── 用例仅描述要实现的行为，不描述这些行为的实现。这种实现用协作描述。</p><p>协作定义交互，描述一组角色实体和其他实体如何通过协同工作来完成一个功能或行为。类可以参与几个协作。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102052151.png" alt="image-20231230102052151"></p></li><li><p>构件（component）── 也称组件，是系统中物理的、可替代的部件。它通常是描述一些逻辑元素的物理包。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102139964.png" alt="image-20231230102139964"></p></li><li><p>节点（node）── 是在运行时存在的物理元素。它代表一种可计算的资源，通常具有一定的记忆能力和处理能力。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102149994.png" alt="image-20231230102149994"></p></li></ol><h4 id="行为事物"><a href="#行为事物" class="headerlink" title="行为事物"></a>行为事物</h4><ul><li>行为事物是UML模型的动态部分，包括两类：</li></ul><ol><li><p><strong>交互（interaction）</strong>── 交互由在特定的上下文环境中共同完成一定任务的一组对象之间传递的消息组成。如图所示。交互涉及的元素包括消息、动作序列（由一个消息所引起的行为）和链（对象间的连接）。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102315130.png" alt="image-20231230102315130"></p></li><li><p><strong>状态机（state machine）</strong>── 描述了一个对象或一个交互在生存周期内响应事件所经历的状态序列，单个类或者一组类之间协作的行为都可以用状态机来描述。</p><p>状态机涉及到状态、变迁和活动，其中状态用圆角矩形来表示。</p><p> <img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102349995.png" alt="image-20231230102349995"></p></li></ol><h4 id="分组事物"><a href="#分组事物" class="headerlink" title="分组事物"></a>分组事物</h4><ul><li>分组事物是UML模型的组织部分。它的作用是为了降低模型复杂性。</li><li>UML中的分组事物是包（package）。</li><li>包是把模型元素组织成组的机制，结构事物、行为事物甚至其他分组事物都可以放进包内。</li></ul><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102455330.png" alt="image-20231230102455330"></p><h4 id="注释事物"><a href="#注释事物" class="headerlink" title="注释事物"></a>注释事物</h4><ul><li>注释事物是UML模型的解释部分，它们用来描述和标注模型的任何元素。</li><li>通常可以用注释修饰带有约束或者解释的图。</li></ul><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102525238.png" alt="image-20231230102525238"></p><h3 id="UML的关系"><a href="#UML的关系" class="headerlink" title="UML的关系"></a>UML的关系</h3><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102748541.png" alt="image-20231230102748541"></p><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><ul><li>依赖(Dependency)是两个事物之间的语义关系，其中一个事物发生变化会影响到另一个事物的语义，它用一个虚线箭头表示。</li><li>虚线箭头的方向从源事物指向目标事物，表示源事物依赖于目标事物。</li></ul><p> </p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230105352997.png" alt="image-20231230105352997"></p><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><ul><li><p>关联(association)是一种结构关系，它描述了两个或多个类的实例之间的连接关系，是一种特殊的依赖。 </p></li><li><p>关联分为<strong>普通关联</strong>、<strong>限定关联</strong>、关联类，以及<strong>聚合</strong>与<strong>复合</strong>。</p></li><li><p><strong>多重性（multiplicity）</strong>：多重性表明在一个关联的两端连接的类实例个数的对应关系，即一端的类的多少个实例对象可以与另一端的类的一个实例相关。</p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101102140470.png" alt="image-20240101102140470"></p></li></ul><h5 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h5><ul><li>聚合（Aggregation）也称为聚集，是一种特殊的关联。它描述了整体和部分之间的结构关系。</li><li>两种特殊的聚合关系：共享聚合（shared aggregation）和复合聚合（composition aggregation）。</li><li>如果在聚合关系中处于部分方的实例可同时参与多个处于整体方实例的构成，则该聚合称为共享聚合。</li><li>如果部分类完全隶属于整体类，部分类需要与整体类共存，一旦整体类不存在了，则部分类也会随之消失，或失去存在价值，则这种聚合称为复合聚合。</li></ul><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101102414333.png" alt="image-20240101102414333"></p><h4 id="泛化关系（继承）"><a href="#泛化关系（继承）" class="headerlink" title="泛化关系（继承）"></a>泛化关系（继承）</h4><p>泛化(generalization)关系就是一般类和特殊类之间的继承关系。在UML中，一般类亦称泛化类，特殊类亦称特化类。</p><h4 id="实现关系（实现）"><a href="#实现关系（实现）" class="headerlink" title="实现关系（实现）"></a>实现关系（实现）</h4><p>**实现(implement)**是泛化关系和依赖关系的结合，也是类之间的语义关系，通常在以下两种情况出现实现关系：</p><ol><li>接口和实现它们的类或构件之间；</li><li>用例和实现它们的协作之间。</li></ol><h3 id="UML的图"><a href="#UML的图" class="headerlink" title="UML的图"></a>UML的图</h3><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102828422.png" alt="image-20231230102828422" style="zoom:80%;" /><h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><blockquote><p>用例模型描述的是外部执行者(actor)所理解的系统功能。用例模型用于需求分析阶段，它的建立是系统开发者和用户反复讨论的结果，描述了开发者和用户对需求规格达成的共识。</p></blockquote><p><strong>四个元素：</strong>1. <strong>系统</strong> 2. <strong>参与者</strong> 3.<strong>用例</strong> 4. <strong>关系</strong></p><ul><li>主要参与者放左边，次要参与者放右边</li><li>包含依赖一定执行，扩展依赖要满足一定条件执行</li></ul><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230123716222.png" alt="image-20231230123716222" style="zoom:70%;" /><p><strong>关系类型</strong>：</p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230115123877.png" alt="image-20231230115123877" style="zoom:0%;" /><p><a href="https://www.bilibili.com/video/BV1qN41177fw/?spm_id_from=333.999.0.0&vd_source=c976b64c190c9a4e94816b10afd4086d">6 分钟学会 UML 用例图_哔哩哔哩_bilibili</a></p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><blockquote><p> 类图描述类和类与类之间的静态关系，它是从静态角度表示系统的，因此类图属于一种静态模型。类图是构建其他图的基础，没有类图就没有状态图、协作图等其他图，也就无法表示系统其他方面的特性。</p><p>类图显示了类（及其接口）、类的内部结构以及与其他类的联系。联系是指类元之间的联系，在类的建模中可以使用关联、聚合和泛化（继承）关系。</p></blockquote><p><strong>类</strong></p><p><strong>关系：</strong></p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230124956825.png" alt="image-20231230124956825"></p><p><strong>聚合（aggregation）关系：</strong>没有父类子类可以独立存在。</p><p><strong>组合（composition）关系：</strong>没有父类子类无法存在。</p><h4 id="交互图"><a href="#交互图" class="headerlink" title="交互图"></a>交互图</h4><h5 id="顺序图（时序图、序列图）"><a href="#顺序图（时序图、序列图）" class="headerlink" title="顺序图（时序图、序列图）"></a>顺序图（时序图、序列图）</h5><blockquote><p>顺序图描述对象之间的动态交互关系，着重表现对象间消息传递的时间顺序。</p></blockquote><p><strong>元素：</strong>角色（Actor）、对象（Object）、生命线（LifeLine）、控制焦点（Activation）、消息（Message）、自关联消息、组合片段</p><p><strong>角色(Actor)</strong><br>系统角色，可以是人或者其他系统，子系统。以一个小人图标表示。</p><p><strong>对象(Object)</strong><br>对象位于时序图的顶部,以一个矩形表示。对象的命名方式一般有三种：<br>    1 对象名和类名。例如：华为手机:手机、loginServiceObject:LoginService。<br>    2 只显示类名，不显示对象，即为一个匿名类。例如：:手机、:LoginSservice。<br>    3 只显示对象名，不显示类名。例如：华为手机:、loginServiceObject:。</p><p><strong>生命线(LifeLine)</strong><br>时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线(对象的时间线)。以一条垂直的虚线表。</p><p><strong>控制焦点(Activation)</strong><br>控制焦点代表时序图中在对象时间线上某段时期执行的操作。以一个很窄的矩形表示。</p><p><strong>消息(Message)</strong><br>表现代表对象之间发送的信息。消息分为三种类型。</p><p> <strong>同步消息(Synchronous Message)</strong><br>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。以一条实线+实心箭头表示。</p><p> <strong>异步消息(Asynchronous Message)</strong><br>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。以一条实线+大于号表示。</p><p><strong>返回消息(Return Message)</strong><br>返回消息表示从过程调用返回。以小于号+虚线表示。</p><p><strong>自关联消息</strong><br>表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。以一个半闭合的长方形+下方实心剪头表示。</p><p><strong>组合片段</strong><br>组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。</p><p><img src="https://img-blog.csdn.net/20180704144557365?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseV96eHk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h5 id="通信图（协作图）"><a href="#通信图（协作图）" class="headerlink" title="通信图（协作图）"></a>通信图（协作图）</h5><blockquote><p>通信图是顺序图的一种变化形式，用于描述相互协作的对象间的交互关系和链接关系。 </p></blockquote><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101114327644.png" alt="image-20240101114327644"></p><h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><blockquote><p>状态图描述一个特定对象的所有可能的状态以及引起状态转换的事件。大多数面向对象技术都用状态图表示单个对象在其生命期中的行为。一个状态图包括一系列状态、事件以及状态之间的转移。</p></blockquote><p><strong>组成：</strong>状态、转换、事件</p><ul><li><strong>状态</strong>：表示对象的生命周期的一种条件&#x2F;情况，有初态和终态之分</li></ul><p><img src="https://pic1.zhimg.com/80/v2-5ebccf8799ff3b33b42ed2235ef1ad78_720w.webp" alt="img"></p><ul><li><p><strong>转换：</strong>两个状态之间的关系，它表明当某事发生时，对象先从当前状态转换到后来的状态，用<strong>带有标记事件的箭头</strong>表示。</p><p><img src="https://pic2.zhimg.com/80/v2-c5b438f27b80c043d9161b6d1dc41a1d_720w.webp" alt="img"></p></li><li><p><strong>事件：</strong>事件时引发变迁的消息，用箭头上的标记（事件表达式）表示。</p></li></ul><h4 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h4><blockquote><p>活动图用来捕捉用例的活动，使用框图的方式显示动作及其结果。</p><p>活动图是一个流图，描述了从活动到活动的流。</p><p>它是另一种描述交互的方式，它描述采取何种动作，动作的结果是什么(动作状态改变)，何时发生(动作序列)，以及在何处发生(泳道)。 </p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/149079804">11. 面向对象——UML活动图（Activity Diagram） - 知乎 (zhihu.com)</a></p><p><a href="https://www.bilibili.com/video/BV1Zp4y1Z7nV/">3 分钟学会 UML 活动图_哔哩哔哩_bilibili</a></p><p>基本元素：1. 活动节点 2. 初始节点和终止节点 3. 转换 4.决策节点（空心菱型） 5.分叉与汇合(黑色粗线)</p><p><strong>泳道图：</strong>按角色进行分组，流程的信息表达更加清晰准确。</p><h4 id="构件图"><a href="#构件图" class="headerlink" title="构件图"></a>构件图</h4><blockquote><p>构件图描述软件构件及构件之间的依赖关系，显示代码的静态结构。</p><p>构件是逻辑架构中定义的概念和功能(例如，类、对象及它们之间的关系)在物理架构中的实现。典型情况下，构件是开发环境中的实现文件。</p></blockquote><p>软件构件分类：</p><ul><li><strong>源构件</strong>：源构件仅在编译时才有意义。典型情况下，它是实现一个或多个类的源代码文件。</li><li><strong>二进制构件</strong>：典型情况下，二进制构件是对象代码，它是源构件的编译结果。</li><li><strong>可执行构件</strong>：可执行构件是一个可执行的程序文件，它是链接所有二进制构件所得到的结果。一个可执行构件代表在处理器(计算机)上运行的可执行单元。</li></ul><h4 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h4><blockquote><p>部署图描述处理器、设备和连接，它显示系统硬件的物理拓扑结构及在此结构上执行的软件。<br>部署图可以显示计算节点的拓扑结构和通信路径、节点上运行的软件以及软件包含的逻辑单元。 </p></blockquote><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101123138498.png" alt="image-20240101123138498" style="zoom:50%;" /><h2 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h2><h3 id="面向对象分析概述"><a href="#面向对象分析概述" class="headerlink" title="面向对象分析概述"></a>面向对象分析概述</h3><h4 id="确定系统边界"><a href="#确定系统边界" class="headerlink" title="确定系统边界"></a>确定系统边界</h4><p>系统边界是系统的所有内部成分与系统以外各种事物的分界线。系统只通过边界上有限数量的接口与外部的系统参与者（人员、组织、设备或外系统）进行交互。</p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101123643096.png" alt="image-20240101123643096" style="zoom:50%;" /><h4 id="面向对象分析的3种模型"><a href="#面向对象分析的3种模型" class="headerlink" title="面向对象分析的3种模型"></a>面向对象分析的3种模型</h4><ul><li><strong>用例模型</strong>：用例和场景表示的功能模型；</li><li><strong>对象模型</strong>：用类和对象表示的静态模型；</li><li><strong>交互模型</strong>：由状态图和顺序图表示的动态模型。</li></ul><h3 id="建立用例模型"><a href="#建立用例模型" class="headerlink" title="建立用例模型"></a>建立用例模型</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li><strong>确定业务参与者</strong>──标识目标系统将支持的不同类型的用户，可以是人、事件或其他系统。</li><li><strong>确定业务需求用例</strong>──参与者需要系统提供的完整功能。</li><li><strong>创建用例图</strong>──标识参与者与用例之间、用例与用例之间的关系。</li></ol><h3 id="建立对象模型"><a href="#建立对象模型" class="headerlink" title="建立对象模型"></a>建立对象模型</h3><h4 id="对象模型的5个层次"><a href="#对象模型的5个层次" class="headerlink" title="对象模型的5个层次"></a>对象模型的5个层次</h4><blockquote><p>Coad &amp; Yourdon提出，复杂问题(大型系统)的对象模型应该由下述5个层次组成：</p><p>主题层(也称为范畴层)、类-对象层、结构层、属性层和服务层，如图所示。 </p></blockquote><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101124901532.png" alt="image-20240101124901532" style="zoom:80%;" /><h3 id="建立动态模型"><a href="#建立动态模型" class="headerlink" title="建立动态模型"></a>建立动态模型</h3><blockquote><p>在开发交互式系统时，动态模型起着很重要的作用。<br>在UML中动态模型的描述工具有顺序图、通信图和状态图。</p></blockquote><h2 id="软件体系结构与设计模式"><a href="#软件体系结构与设计模式" class="headerlink" title="软件体系结构与设计模式"></a>软件体系结构与设计模式</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><a href="https://makeoptim.com/training/typescript-design-patterns">软件修养 – 一篇搞定设计原则和 23 种设计模式 | MakeOptim</a></p><h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><h5 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h5><p>定义一个<strong>创建对象的接口</strong>，但让<strong>实现这个接口的类</strong>来决定<strong>实例化哪个类</strong>。工厂方法让类的实例化<strong>推迟到子类中进行</strong>。</p><h5 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h5><p>为一个<strong>产品族</strong>提供了<strong>统一的创建接口</strong>。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类，而<strong>无需指定它们的具体类</strong>。</p><h4 id="构造型"><a href="#构造型" class="headerlink" title="构造型"></a>构造型</h4><h5 id="适配器模式（Adapter、Wrapper、Translator）"><a href="#适配器模式（Adapter、Wrapper、Translator）" class="headerlink" title="适配器模式（Adapter、Wrapper、Translator）"></a>适配器模式（Adapter、Wrapper、Translator）</h5><p>将某个类的接口<strong>转换成客户端期望的</strong>另一个<strong>接口表示</strong>。适配器模式可以<strong>消除由于接口不匹配</strong>所造成的<strong>类兼容性问题</strong>。</p><h4 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h4><h5 id="观察者模式（Observer-or-Publish-subscribe）"><a href="#观察者模式（Observer-or-Publish-subscribe）" class="headerlink" title="观察者模式（Observer or Publish&#x2F;subscribe）"></a>观察者模式（Observer or Publish&#x2F;subscribe）</h5><p>在对象间定义一个<strong>一对多</strong>的联系性，由此<strong>当一个对象改变</strong>了状态，所有其他<strong>相关的对象</strong>会被<strong>通知</strong>并且<strong>自动刷新</strong>。</p><h6 id="黑板模式-Blackboard-Design-Pattern"><a href="#黑板模式-Blackboard-Design-Pattern" class="headerlink" title="黑板模式(Blackboard Design Pattern)"></a>黑板模式(Blackboard Design Pattern)</h6><p>黑板模式（Blackboard Design Pattern）是<strong>观察者模式的一个扩展</strong>：<strong>允许消息的读写同时进行</strong>，广泛地交互消息。</p><h5 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h5><p>定义一个<strong>算法的系列</strong>，将其各个<strong>分装</strong>，并且使他们<strong>有交互性</strong>。策略模式使得<strong>算法</strong>在用户使用的时候能<strong>独立的改变</strong>。</p><h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><h3 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h3><p><a href="https://makeoptim.com/tags#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">Tags | MakeOptim</a></p><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>单一职责原则（SRP：Single responsibility principle）：一个类应该<strong>只有一个发生变化的原因</strong>，即一个类<strong>只负责一项职责</strong>。</p><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>开闭原则（OCP ：Open Closed Principle）：软件中的<strong>实体（类，模块，函数等等）</strong>应该<strong>对扩展开放，对修改封闭</strong>，这意味着一个实体是允许在<strong>不改变它的源代码的前提下变更它的行为</strong>。</p><h4 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h4><p>里氏替换原则（LSP：Liskov Substitution Principle）：<strong>派生类（子类）对象可以在程序中代替其基类（超类）对象</strong>。</p><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p>依赖倒置原则（DIP ：Dependence Inversion Principle）：</p><ul><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><p><strong>也就是说高层模块，低层模块，细节都应该依赖抽象</strong></p><h4 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h4><p>迪米特法则（LOD：Law Of Demeter）：又叫作<strong>最少知识原则</strong>（Least Knowledge Principle，LKP)。只与你的<strong>直接的</strong>朋友交谈，<strong>不跟“陌生人”说话</strong>（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体<strong>无须直接通信</strong>，那么就<strong>不应当发生直接的相互调用</strong>，可以通过第三方<strong>转发</strong>该调用。其目的是<strong>降低类之间的耦合度</strong>，提高模块的相对<strong>独立性</strong>。</p><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p>接口隔离原则（ISP ：Interface Segregation Principle）：客户端<strong>不应该依赖它不需要的接口</strong>。一个类对另一个类的依赖应该建立在<strong>最小的接口</strong>上。</p><h4 id="组合-聚合原则"><a href="#组合-聚合原则" class="headerlink" title="组合&#x2F;聚合原则"></a>组合&#x2F;聚合原则</h4><p>组合&#x2F;聚合复用原则（CARP：Composite&#x2F;Aggregate Reuse Principle）：在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新对象通过向这些对象的委派达到复用已有功能的目的。就是说要尽量的使用合成和聚合，而<strong>不是继承关系达到复用的目的</strong>。</p><p>简短表达就是：<strong>尽量使用组合&#x2F;聚合，尽量不要使用继承</strong>。</p><h2 id="软件测试方法"><a href="#软件测试方法" class="headerlink" title="软件测试方法"></a>软件测试方法</h2><h3 id="软件测试的基本概念"><a href="#软件测试的基本概念" class="headerlink" title="软件测试的基本概念"></a>软件测试的基本概念</h3><p><strong>什么是软件测试？</strong></p><ul><li>软件测试是在软件投入生产性运行之前，对软件需求分析、设计规格说明和编码的最终复审，是软件质量控制的关键步骤。</li><li>软件测试是为了发现错误而执行程序的过程。</li><li>或者说，软件测试是根据软件开发各阶段的规格说明和程序的内部结构而精心设计一批测试用例（即输入数据及其预期的输出结果），并利用这些测试用例去运行程序，以发现程序错误的过程。</li></ul><p><strong>软件测试的目的</strong></p><p>​基于不同的立场，存在着两种完全不同的测试目的。</p><ul><li>从用户的角度出发，普遍希望通过软件测试检验软件中隐藏的错误和缺陷，以考虑是否可以接受该产品。</li><li>从软件开发者的角度出发，则希望测试成为表明软件产品中不存在错误的过程，验证该软件已正确地实现了用户的要求，确立人们对软件质量的信心。</li></ul><p><strong>测试方法与技术</strong></p><ul><li><p>机器测试</p><p>在设定的测试数据上执行被测程序的过程。又称动态测试。</p></li><li><p>人工测试</p><p>采用人工方法进行，目的在于检查程序的静态结构，找出编译不能发现的错误。</p></li></ul><p><strong>人工测试分类</strong></p><ul><li>代码审查<br>以小组会的形式，发现程序在结构、功能、编码风格等方面存在的问题。可查出30%~70%的错误</li><li>走查<br>以小组会的形式进行，把测试数据“输入”到被测程序，并在纸上跟踪监视程序的执行情况，让人代替机器沿着程序的逻辑走一遍。</li><li>桌前检查<br>设计模块时，程序员自己检查。</li></ul><p><strong>机器测试分类</strong></p><ul><li>黑盒测试</li></ul><blockquote><p>黑盒测试是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。</p></blockquote><ul><li>白盒测试</li></ul><blockquote><p>白盒测试是对软件的过程性细节做细致的检查。<br>这一方法是把测试对象看做一个打开的盒子或透明的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。<br>通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。<br>因此，白盒测试又称为结构测试或逻辑驱动测试。</p></blockquote><h3 id="白盒测试的测试用例设计"><a href="#白盒测试的测试用例设计" class="headerlink" title="白盒测试的测试用例设计"></a>白盒测试的测试用例设计</h3><h4 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h4><blockquote><p>逻辑覆盖是以程序内部的逻辑结构为基础的设计测试用例</p><p>的技术，它属于白盒测试。</p></blockquote><p>由于覆盖测试的目标不同，逻辑覆盖又可分为： </p><ul><li>语句覆盖</li><li>判定覆盖</li><li>判定—条件覆盖</li><li>条件组合覆盖</li><li>路径覆盖</li></ul><h4 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a>语句覆盖</h4><blockquote><p>语句覆盖就是设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次。</p></blockquote><h4 id="判定覆盖"><a href="#判定覆盖" class="headerlink" title="判定覆盖"></a>判定覆盖</h4><blockquote><p>判定覆盖就是设计若干个测试用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次。判定覆盖又称为分支覆盖。</p></blockquote><h4 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h4><blockquote><p>条件覆盖就是设计若干个测试用例，运行被测程序，使得程序中每个判断的每个条件的可能取值至少执行一次。</p><p>每个条件真假走一次</p></blockquote><h4 id="判定-条件覆盖"><a href="#判定-条件覆盖" class="headerlink" title="判定-条件覆盖"></a>判定-条件覆盖</h4><blockquote><p>所谓判定-条件覆盖就是设计足够的测试用例，使得判断中<br>每个条件的所有可能取值至少执行一次，同时每个判断本身<br>的所有可能判断结果至少执行一次。</p></blockquote><h4 id="条件组合覆盖"><a href="#条件组合覆盖" class="headerlink" title="条件组合覆盖"></a>条件组合覆盖</h4><blockquote><p>条件组合覆盖就是设计足够的测试用例，运行被测程序，使得每个判断的所有可能的条件取值组合至少执行一次。</p></blockquote><h4 id="路径测试"><a href="#路径测试" class="headerlink" title="路径测试"></a>路径测试</h4><blockquote><p>路径测试是设计足够的测试用例，覆盖程序中所有可能的路径。</p></blockquote><h3 id="基本路径覆盖"><a href="#基本路径覆盖" class="headerlink" title="基本路径覆盖"></a>基本路径覆盖</h3><p>基本路径测试是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。</p><h3 id="黑盒测试的测试用例设计"><a href="#黑盒测试的测试用例设计" class="headerlink" title="黑盒测试的测试用例设计"></a>黑盒测试的测试用例设计</h3><h4 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h4><ul><li>等价类划分是一种典型的黑盒测试方法，也是一种非常实用的重要测试方法,它是用来解决如何选择适当的子集，使其尽可能多地发现错误。</li><li>使用这一方法设计测试用例要经历<strong>划分等价类</strong>（列出等价类表）和<strong>选取测试用例</strong>两步。</li></ul><h5 id="划分等价类"><a href="#划分等价类" class="headerlink" title="划分等价类"></a>划分等价类</h5><p>所谓等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，并合理地假定：测试某等价类的代表值等价于对这一类其他值的测试。</p><p><strong>等价类的划分</strong>：</p><ol><li><p><strong>有效等价类</strong></p><p>有效等价类：是指对于程序的规格说明来说，是合理的、有意义的输入数据构成的集合。利用它，可以检验程序是否实现了规格说明预先规定的功能和性能。</p></li><li><p><strong>无效等价类</strong></p><p>是指对于程序的规格说明来说，是不合理的、无意义的输入数据构成的集合。程序员主要利用这一类测试用例检查程序中功能和性能的实现是否有不符合规格说明要求的地方。</p></li></ol><p>​在设计测试用例时，要同时考虑有效等价类和无效等价类的设计。</p><h5 id="确定测试用例"><a href="#确定测试用例" class="headerlink" title="确定测试用例"></a>确定测试用例</h5><p>在确定了等价类之后，建立等价类表，列出所有划分出的等价类，如下： </p><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102162856504.png" alt="image-20240102162856504"></p><p>再从划分出的等价类中按以下原则选择测试用例。<br>（1）为每一个等价类规定一个唯一的编号。<br>（2）设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止。<br>（3）设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。</p><h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4><ul><li>边界值分析也是一种黑盒测试方法，是对等价类划分方法的补充。人们从长期的测试工作经验中得知，大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部。</li><li>这里所说的边界是指，相当于输入等价类和输出等价类而言，稍高于其边界值及稍低于其边界值的一些特定情况。</li></ul><h3 id="软件测试策略"><a href="#软件测试策略" class="headerlink" title="软件测试策略"></a>软件测试策略</h3><p>通常<strong>软件测试过程</strong>按4个步骤进行，即<mark>单元测试</mark>、<mark>组装测试(集成测试)</mark>、<mark>确认测试</mark>和<mark>系统测试</mark>。如下图所示。</p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102161943964.png" alt="image-20240102161943964" style="zoom: 60%;" /><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><blockquote><p>单元测试（unit testing）又称模块测试，是针对软件设计的最小单位—程序模块，进行正确性检验的测试工作。其目的在于发现各模块内部可能存在的各种差错。单元测试需要从程序的内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。</p></blockquote><h5 id="单元测试内容"><a href="#单元测试内容" class="headerlink" title="单元测试内容"></a>单元测试内容</h5><blockquote><p>单元测试主要采用白盒测试方法设计测试用例，辅之以黑盒测试的测试用例，使之对任何合理的输入和不合理的输入，都能鉴别和响应。在单元测试中进行的测试工作如下图所示，需要在5个方面对被测模块进行检查。 </p></blockquote><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102164134720.png" alt="image-20240102164134720" style="zoom: 80%;" /><ol><li>模块接口测试</li><li>局部数据结构测试</li><li>路径测试</li><li>错误处理测试</li><li>边界测试</li></ol><h5 id="单元测试步骤"><a href="#单元测试步骤" class="headerlink" title="单元测试步骤"></a>单元测试步骤</h5><ol><li>驱动模块</li><li>桩模块</li></ol><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102185005911.png" alt="image-20240102185005911" style="zoom:50%;" /><h4 id="组装测试"><a href="#组装测试" class="headerlink" title="组装测试"></a>组装测试</h4><blockquote><p>组装测试（integrated testing）也叫做集成测试或联合测试。通常，在单元测试的基础上，需要将所有模块按照设计要求组装成为系统，把模块组装为系统的方式有两种：一次性组装方式（big bang）和增值式组装方式。</p></blockquote><h4 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h4><blockquote><p>确认测试（validation testing）又称有效性测试。它的任务是验证软件的有效性，即验证软件的功能和性能及其他特性是否与用户的要求一致。在确认测试阶段需要做的工作如下图所示。</p></blockquote><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102185138824.png" alt="image-20240102185138824" style="zoom:80%;" /><ol><li><p>进行有效性测试（黑盒测试）</p></li><li><p>软件配置复查</p></li><li><p>α测试和β测试</p><p>α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试。软件在一个自然设置状态下使用，开发者坐在用户旁边，随时记下错误情况和使用中的问题。 α测试的目的是评价软件产品的FLURPS（即功能、局域化、可使用性、可靠性、性能和支持），尤其注重产品的界面和特色。</p><p>β测试是由软件的多个用户在一个或多个用户的实际使用环境下进行的测试。这些用户是与公司签定了支持产品预发行合同的外部客户。与α测试不同的是，开发者通常不在测试现场，由用户记下遇到的所有问题。开发者在综合用户的报告之后进行修改，最后将软件产品交付给全体用户使用。β测试主要衡量产品的FLURPS，着重于产品的支持性，包括文档、客户培训和支持产品生产能力。只有当α测试达到一定的可靠程度时，才能开始β测试。 </p></li><li><p>验收测试</p></li><li><p>确认结果测试</p></li></ol><h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><blockquote><p>系统测试（system testing）是将通过确认测试的软件，作为整个计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据、人员等其他系统元素结合在一起，在实际运行（使用）环境下，对计算机系统进行一系列的组装测试和确认测试。</p><p>系统测试的目的在于通过与系统的需求定义作比较，发现软件与系统定义不符合或与之矛盾的地方。系统测试的测试用例应根据系统的需求分析说明书设计，并在实际使用环境下运行。</p></blockquote><h4 id="测试的类型"><a href="#测试的类型" class="headerlink" title="测试的类型"></a>测试的类型</h4><p>（1）功能测试（function testing）：功能测试是在规定的一段时间内运行软件系统的所有功能，以验证这个软件系统有无严重错误。</p><p>（2）回归测试（regression testing）：这种测试用于验证对软件修改后有没有引出新的错误，或者说，验证修改后的软件是否仍然满足系统的需求规格说明。</p><p>（3）可靠性测试（reliability testing）：如果系统需求说明书中有对可靠性的要求，则需进行可靠性测试。通常使用平均失效间隔时间（MTBF）与因故障而停机的时间（MTTR）来度量系统的可靠性。 </p><p>（4）强度测试（stress testing）：也称压力测试，是要检查在系统运行环境恶劣的情况下，系统可以运行到何种程度的测试。因此，进行强度测试，需要提供非正常数量、频率或总量资源来运行系统。实际上，这是对软件的“超负荷”环境或临界环境的运行检验。</p><p>（5）性能测试（performance testing）：是要检查系统是否满足在需求说明书中规定的性能。特别是对于实时系统或嵌入式系统，软件只满足要求的功能而达不到要求的性能是不可接受的，所以还需要进行性能测试。</p><p>（6）恢复测试（recovery testing）：恢复测试是要证实在克服硬件故障（包括掉电、硬件或网络出错等）后，系统能否正常地继续进行工作，并不对系统造成任何损害。</p><p>（7）启动&#x2F;停止测试（startup&#x2F;shutdown testing）：这类测试的目的是验证在机器启动及关机阶段，软件系统正确处理的能力。包括反复启动软件系统（例如，操作系统自举、网络的启动、应用程序的调用等），以及在尽可能多的情况下关机。</p><p>（8）配置测试（configuration testing）：这类测试是要检查计算机系统内各个设备或各种资源之间的相互连接和功能分配中的错误。配置测试主要包括以下3种。</p><p>  ① 配置命令测试：验证全部配置命令的可操作性（有效 </p><p>  性）；特别对最大配置和最小配置要进行测试。软件配置 </p><p>  和硬件配置都要测试。</p><p>  ② 循环配置测试：证明对每个设备物理与逻辑的、逻辑</p><p>  与功能的每次循环置换配置都能正常工作。</p><p>  ③ 修复测试：检查每种配置状态及哪个设备是坏的，并 </p><p>  用自动的或手工的方式进行配置状态间的转换。</p><p>（9）安全性测试（security testing）：检验在系统中已经存在的系统安全性和保密性措施是否发挥作用，有无漏洞。为此要了解破坏安全性的方法和工具，并设计一些模拟测试用例对系统进行测试，力图破坏系统的保护机构以进入系统。</p><p>（10）可使用性测试（usability testing）：可使用性测试主要从使用的合理性、方便性等角度对软件系统进行检查，以发现人为因素或使用上的问题。</p><p>（11）可支持性测试（supportability testing）：验证系统的支持策略对于公司与用户方面是否切实可行。它所采用的方法是试运行支持过程（如对有错部分打补丁的过程，热线界面等），对其结果进行质量分析，评审诊断工具、维护过程、内部维护文档；衡量修复一个明显错误所需的平均最少时间。还有一种常用的方法是，在发行前把产品交给用户，向用户提供支持服务的计划，从用户处得到对支持服务的反馈。</p><p>（12）安装测试（installation testing）：安装测试的目的不是查找软件错误，而是查找安装错误。在安装软件系统时，会有多种选择。要分配和装入文件与程序库，布置适用的硬件配置，进行程序的连接。而安装测试是要查找出在这些安装过程中出现的错误。</p><p>（13）互连测试（interoperability testing）：验证两个或多个不同的系统之间的互连性。这类测试对支持标准规格说明，或承诺支持与其他系统互连的软件系统有效。</p><p>（14）兼容性测试（compatibility testing）：验证软件产品在不同版本之间的兼容性。有两类基本的兼容性测试：向下兼容和交错兼容。向下兼容测试是测试软件新版本，保留它早期版本的功能的情况；交错兼容测试是要验证共同存在的两个相关但不同的产品之间的兼容性。</p><p>（15）容量测试（volume testing）：容量测试是要检验系统的能力最高能达到什么程度。</p><p>（16）文档测试（documentation testing）：检查用户文档（如用户手册）的清晰性和精确性。用户文档中所使用的例子必须在测试中一一试过，确保叙述正确无误。</p><h2 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h2><h3 id="软件维护的概念"><a href="#软件维护的概念" class="headerlink" title="软件维护的概念"></a>软件维护的概念</h3><blockquote><p>软件维护是指在软件运行&#x2F;维护阶段对软件产品所进行的修改就是所谓的维护。</p></blockquote><p>根据维护工作的性质，软件维护的活动可以分为以下4种类型。</p><ul><li>改正性维护</li><li>适应性维护</li><li>完善性维护</li><li>预防性维护</li></ul><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240103235351538.png" alt="image-20240103235351538" style="zoom:50%;" /><h4 id="改正性维护"><a href="#改正性维护" class="headerlink" title="改正性维护"></a>改正性维护</h4><blockquote><p>改正性维护（corrective maintenance）为了识别和纠正软件错误、改正软件性能上的缺陷、排除实施中的误使用，应进行的诊断和改正错误的过程。例如，改正性维护可以是改正原来程序中开关使用的错误；解决开发时未能测试各种可能情况带来的问题等。 </p></blockquote><h4 id="适应性维护"><a href="#适应性维护" class="headerlink" title="适应性维护"></a>适应性维护</h4><blockquote><p>随着信息技术的飞速发展，软件运行的外部环境（新的硬、软件配置）或数据环境（数据库、数据格式、数据输入&#x2F;输出方式、数据存储介质）可能发生变化，为了使软件适应这种变化，而修改软件的过程叫做适应性维护（adaptive maintenance）。例如，需要对已运行的软件进行改造，以适应网络环境或已升级改版的操作系统要求。</p></blockquote><h4 id="完善性维护"><a href="#完善性维护" class="headerlink" title="完善性维护"></a>完善性维护</h4><blockquote><p>为了满足新的功能与性能要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。这种情况下进行的维护活动叫做完善性维护（perfective maintenance）。</p></blockquote><h4 id="预防性维护"><a href="#预防性维护" class="headerlink" title="预防性维护"></a>预防性维护</h4><blockquote><p>预防性维护（preventive maintenance）是指把今天的方法学用于昨天的系统以满足明天的需要。也就是说，采用先进的软件工程方法对需要维护的软件或软件中的某一部分（重新）进行设计、编码和测试。</p></blockquote><h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><blockquote><p>重构就是在不改变代码外在行为的前提下，修改代码来改进程序的内部结构，提高程序的可理解性和可维护性等，进而帮助尽早的发现缺陷，提高编程速度。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Typora大纲与标题配置序号</title>
      <link href="/posts/4600/"/>
      <url>/posts/4600/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>进入Typora主题文件根目录</p></li><li><p>新建文件<code>base.user.css</code>,复制下面内容</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Path: base.user.css */</span></span><br><span class="line"><span class="comment">/* 侧边目录添加编号 二级标题开始*/</span></span><br><span class="line"><span class="selector-class">.sidebar-content</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.outline-h2</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h3</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.outline-h3</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h4</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.outline-h4</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h5</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.outline-h5</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h6</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-class">.outline-h2</span>&gt;<span class="selector-class">.outline-item</span>&gt;<span class="selector-class">.outline-label</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: h2;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h2) <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.outline-h3</span>&gt;<span class="selector-class">.outline-item</span>&gt;<span class="selector-class">.outline-label</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: h3;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.outline-h4</span>&gt;<span class="selector-class">.outline-item</span>&gt;<span class="selector-class">.outline-label</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: h4;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.outline-h5</span>&gt;<span class="selector-class">.outline-item</span>&gt;<span class="selector-class">.outline-label</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: h5;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5) <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.outline-h6</span>&gt;<span class="selector-class">.outline-item</span>&gt;<span class="selector-class">.outline-label</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: h6;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h6) <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标题添加编号 */</span></span><br><span class="line"><span class="selector-id">#write</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h3</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h4</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">h4</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h5</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">h5</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h6</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** put counter result into headings */</span></span><br><span class="line">    <span class="selector-id">#write</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: h2;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-id">#write</span> <span class="selector-tag">h3</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-tag">h3</span><span class="selector-class">.md-focus</span><span class="selector-class">.md-heading</span><span class="selector-pseudo">:before</span> <span class="comment">/** override the default style for focused headings */</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: h3;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-id">#write</span> <span class="selector-tag">h4</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-tag">h4</span><span class="selector-class">.md-focus</span><span class="selector-class">.md-heading</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: h4;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-id">#write</span> <span class="selector-tag">h5</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-tag">h5</span><span class="selector-class">.md-focus</span><span class="selector-class">.md-heading</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: h5;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-id">#write</span> <span class="selector-tag">h6</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-tag">h6</span><span class="selector-class">.md-focus</span><span class="selector-class">.md-heading</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: h6;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h6)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** override the default style for focused headings */</span></span><br><span class="line">    <span class="selector-id">#write</span>&gt;<span class="selector-tag">h3</span><span class="selector-class">.md-focus</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-id">#write</span>&gt;<span class="selector-tag">h4</span><span class="selector-class">.md-focus</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-id">#write</span>&gt;<span class="selector-tag">h5</span><span class="selector-class">.md-focus</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-id">#write</span>&gt;<span class="selector-tag">h6</span><span class="selector-class">.md-focus</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-tag">h3</span><span class="selector-class">.md-focus</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-tag">h4</span><span class="selector-class">.md-focus</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-tag">h5</span><span class="selector-class">.md-focus</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-tag">h6</span><span class="selector-class">.md-focus</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: inherit;</span><br><span class="line">    <span class="attribute">border</span>: inherit;</span><br><span class="line">    <span class="attribute">border-radius</span>: inherit;</span><br><span class="line">    <span class="attribute">position</span>: inherit;</span><br><span class="line">    <span class="attribute">left</span>:initial;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">top</span>:initial;</span><br><span class="line">    <span class="attribute">font-size</span>: inherit;</span><br><span class="line">    <span class="attribute">padding-left</span>: inherit;</span><br><span class="line">    <span class="attribute">padding-right</span>: inherit;</span><br><span class="line">    <span class="attribute">vertical-align</span>: inherit;</span><br><span class="line">    <span class="attribute">font-weight</span>: inherit;</span><br><span class="line">    <span class="attribute">line-height</span>: inherit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>重启Typora</p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102110921512.png" alt="image-20240102110921512" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 知识碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows杀死占用端口的进程</title>
      <link href="/posts/windows72hej792/"/>
      <url>/posts/windows72hej792/</url>
      
        <content type="html"><![CDATA[<h2 id="查找端口占用"><a href="#查找端口占用" class="headerlink" title="查找端口占用"></a>查找端口占用</h2><p>打开<code>cmd</code>输入下面指令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -aon|findstr <span class="string">&quot;8081&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>netstat -aon</code> 是一个 Windows 命令行命令，用于显示当前系统中所有活动的网络连接和监听端口，并列出与每个连接相关的进程 ID（PID）。</p></li><li><p><code>|</code> 是管道符号，用于将一个命令的输出传递给另一个命令进行处理。</p></li><li><p><code>findstr &quot;8081&quot;</code> 是一个 Windows 命令行命令，用于在文本中查找包含指定字符串（这里是 “8081”）的行，并将这些行输出到命令行窗口。</p></li></ul><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /T /F /PID 8081</span><br></pre></td></tr></table></figure><ul><li><code>/T</code> 参数表示终止指定进程及其所有子进程。</li><li><code>/F</code> 参数表示强制终止进程，而不显示终止确认提示。</li><li><code>/PID 8081</code> 参数指定要终止的进程的 PID。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows使用右键新建与使用模版</title>
      <link href="/posts/windows8226/"/>
      <url>/posts/windows8226/</url>
      
        <content type="html"><![CDATA[<p>​当我们在日常写作和博客撰写中使用模板和右键新建功能时，可以极大地提高创建和组织文章内容的效率。然而，许多网上的教程可能会让这个过程显得比较繁琐。在本文中，我将分享一个简单的方法，可以轻松地使用右键新建.md文件并指定模板。这个方法同样适用于创建其他类型的文件。接下来，我将介绍如何利用这两个功能来快速撰写博客文章。</p><p>​！！！请注意，下面注册表编辑器的设置将影响到系统中所有的 <code>.md</code> 文件。确保在进行修改之前，备份注册表或者只对特定用户进行修改，以避免不必要的问题。</p><h2 id="右键添加新建Markdown选项"><a href="#右键添加新建Markdown选项" class="headerlink" title="右键添加新建Markdown选项"></a>右键添加新建<code>Markdown</code>选项</h2><ol><li><p>桌面新建个txt文件</p></li><li><p>复制下面内容到新建的文件中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@=<span class="string">&quot;Typora.exe&quot;</span></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line"><span class="string">&quot;NullFile&quot;</span>=<span class="string">&quot;&quot;</span></span><br><span class="line">[HKEY_CLASSES_ROOT\Typore.exe]</span><br><span class="line">@=<span class="string">&quot;Markdown&quot;</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li><code>[HKEY_CLASSES_ROOT\.md]</code><ul><li>这一行指定了注册表中的一个键路径，即文件扩展名为 <code>.md</code> 的文件的关联设置。</li></ul></li><li><code>@=&quot;Typora.exe&quot;</code><ul><li>这一行设置了文件扩展名为 <code>.md</code> 的文件的默认关联程序为 <code>Typora.exe</code>。也就是说，当你双击打开 <code>.md</code> 文件时，系统会使用 <code>Typora.exe</code> 来打开它。</li></ul></li><li><code>[HKEY_CLASSES_ROOT\.md\ShellNew]</code><ul><li>这一行指定了注册表中的另一个键路径，用于定义在右键菜单的 “新建” 选项中创建 <code>.md</code> 文件时的行为。</li></ul></li><li><code>&quot;NullFile&quot;=&quot;&quot;</code><ul><li>这一行设置了在右键菜单的 “新建” 选项中创建 <code>.md</code> 文件时，用一个空文件作为模板。</li></ul></li><li><code>[HKEY_CLASSES_ROOT\Typora.exe]</code><ul><li>这一行指定了注册表中的另一个键路径，用于定义 <code>Typora.exe</code> 这个应用程序的相关设置。</li></ul></li><li><code>@=&quot;Markdown&quot;</code><ul><li>这一行设置了 <code>Typora.exe</code> 这个应用程序的默认描述为 “Markdown”。这将在文件关联和其他系统操作中显示相关描述。（右键新建显示<code>Markdown</code>）</li></ul></li></ol></li><li><p>改文件的后缀为<code>.reg</code></p></li><li><p>双击运行程序</p></li></ol><h2 id="新建的文件使用模版"><a href="#新建的文件使用模版" class="headerlink" title="新建的文件使用模版"></a>新建的文件使用模版</h2><p>操作相同，代码内容换成下面的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@=<span class="string">&quot;Typora.exe&quot;</span></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line"><span class="string">&quot;FileName&quot;</span>=<span class="string">&quot;D:\\template\\Template.md&quot;</span></span><br><span class="line">[HKEY_CLASSES_ROOT\Typore.exe]</span><br><span class="line">@=<span class="string">&quot;Markdown&quot;</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p><code>[HKEY_CLASSES_ROOT\.md\ShellNew]</code>：这一行指定了注册表中的一个键路径，用于定义在右键菜单的 “新建” 选项中创建 <code>.md</code> 文件时的行为。</p><p><code>&quot;FileName&quot;=&quot;D:\template\Template.md&quot;</code>：这一行设置了键值 <code>FileName</code> 的数据，即指定了模板文件的完整路径。在这个例子中，模板文件路径为 <code>D:\\template\\Template.md</code>。</p><ul><li>注意：需要使用两个<code>\\</code>，模版可以放到自己想要的地方</li></ul><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA.gif" alt="效果演示"></p><ul><li>从上图中可以看成当我们右键时是没有<code>Markdown</code>选项的，当我们运行第二个程序时，右键出现的<code>Markdown</code>选项，新建出来的文件使用了模版。</li></ul><p>​通过这种简化的方法，你可以更轻松地在日常写作中使用模板和右键新建功能，从而提高工作效率。不再需要繁琐的步骤，你可以快速创建带有指定模板的.md文件，专注于内容的创作和组织。</p><p>​希望这个简化的方法能对你在博客撰写中有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> 知识碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/posts/16574/"/>
      <url>/posts/16574/</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h3><p>栈是一种特殊的线性结构，总在栈尾处增加（push）或删除（pop）元素，是典型的LIFO数据结构。</p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/screen-shot-2018-06-02-at-203523.png" alt="img" style="zoom:50%;" /><h3 id="在Java中的使用"><a href="#在Java中的使用" class="headerlink" title="在Java中的使用"></a>在Java中的使用</h3><p>​在java中栈是Vector的一个子类，正是由于这个原因Stack继承了Vector的所有方法，并可以在任意位置添加或删除元素。这种能力无疑是破坏了栈这种数据结构的封装性。由于这种原因官方推荐使用Deque（双端队列）接口来代替栈的功能，但是双端队列可以双端操作，还是会破坏栈这种数据结构的封装性。但是这是历史遗留问题。现在工程中可以自己封装一个真正的栈来使用。</p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231225213124369.png" alt="image-20231225213124369" style="zoom:50%;" /><table><thead><tr><th>操作</th><th>成功</th><th>失败</th></tr></thead><tbody><tr><td>push</td><td>void</td><td>void</td></tr><tr><td>pop</td><td>栈顶元素</td><td>NoSuchElementException</td></tr><tr><td>peek</td><td>栈顶元素</td><td>空返回null</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化队列</span></span><br><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 2. 入栈</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 3. 查看栈顶元素</span></span><br><span class="line">System.out.println(stack.peek());</span><br><span class="line"><span class="comment">// 4. 出栈</span></span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.peek());<span class="comment">// 空返回null</span></span><br><span class="line">System.out.println(stack.pop()); <span class="comment">// 空抛出异常NoSuchElementException</span></span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h3><p>队列是一种特殊的线性结构，总在队列头删除（dequeue）元素，队列结尾插入（enqueue）元素，是典型的FIFO数据结构。</p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/screen-shot-2018-05-03-at-151021.png" alt="img" style="zoom:50%;" /><h3 id="在Java中的使用-1"><a href="#在Java中的使用-1" class="headerlink" title="在Java中的使用"></a>在Java中的使用</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li><strong>单向队列（Queue）</strong>：只能在一端插入数据，在另一端删除数据。</li><li><strong>双向队列（Deque）</strong>：每一端都可以进行插入数据和删除数据的操作。</li><li><strong>优先级队列</strong>：优先级队列是比栈和队列更专用的数据结构，在优先级队列中，数据项按照关键字进行排序，关键字最小（或者最大）的数据项往往在队列的最前面，而数据项在插入的时候都会插入到合适的位置以确保队列的有序。</li></ol><h4 id="java类图"><a href="#java类图" class="headerlink" title="java类图"></a>java类图</h4><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226110249047.png" alt="image-20231226110249047" style="zoom:50%;" /><h4 id="队列常用操作"><a href="#队列常用操作" class="headerlink" title="队列常用操作"></a>队列常用操作</h4><table><thead><tr><th>操作</th><th>功能</th><th>结果</th></tr></thead><tbody><tr><td>add</td><td>添加一个元素</td><td>如果队列已满，则抛出一个</td></tr><tr><td>remove</td><td>移除并返回队列头部的元素</td><td>如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td>element</td><td>返回队列头部的元素</td><td>如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td>offer</td><td>添加一个元素并返回true</td><td>如果队列已满，则返回null</td></tr><tr><td>peek</td><td>返回队列头部的元素</td><td>如果队列为空则返回null</td></tr><tr><td>poll</td><td>移除并返回队列头部的元素</td><td>如果队列为空，则返回null</td></tr><tr><td>put</td><td>添加一个元素</td><td>如果队列满，则阻塞</td></tr><tr><td>take</td><td>移除并返回队列头部的元素</td><td>如果队列为空，则阻塞</td></tr></tbody></table><h4 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h4><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226113239001.png" alt="image-20231226113239001"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        queue.offer(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取队首元素，如果没有返回null</span></span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        <span class="comment">// 获取队首元素并删除，如果没有返回null</span></span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h4><p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226235105641.png" alt="image-20231226235105641"></p><h4 id="PriorityQueue类"><a href="#PriorityQueue类" class="headerlink" title="PriorityQueue类"></a>PriorityQueue类</h4><p>优先队列，底层使用堆实现</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Tommy_____/article/details/106445631">Java 程序员，别用 Stack？！_工作中会用到stack类么-CSDN博客</a></p><p><a href="https://leetcode.cn/leetbook/detail/queue-stack/">队列 &amp; 栈 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台</a></p><p><a href="https://juejin.cn/post/7215177412908367932">搞懂Java中的队列以及使用场景 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式</title>
      <link href="/posts/7315/"/>
      <url>/posts/7315/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="246168ed985e8f729ce69f25c7eea3ea4620e1ef8b17cde1f36b527f85536b27">a63818ebb849064e381614be9ab2d9e78acbc0f6d21a3bd98cb08bf39a162e725086cd1ad98653aebfc9d8e033a0b260a7fd50335c086db2104b55b04ac7a504360c4333df95ff108ae797dfeda5fa728aa8e5bba5f22d18f04f8e5f29178b885080c187e11d2b5548b0e2108799f67414e62f6a74677e7bf411c7f5a3629394d966c823d0be0ef5f02ddd8b6dfc60635c9e492465a3c727d3a303949e6cb7515e0ace73149cf9bb3948fc96d808f8223e37ae6850bc64b909f0dfcc4948c5c0b35b940e80cc02bd4b680f0e42abcce698fe81e95abc8d63461711dc84fff682f8df5bb07a2329b77e07c41c912adaaad3ebfd00b5de2266f9c66f9f7f011ad67cd69b54bd26cf65346261aeb905c7af1fdaeecdb91f34c32f3c88ba4d82504dec7359cd990caa11fd7bd325468ceedc1e20c90d317f2675a8c42da312d4a83d6ff2d52a2fccac5ed0d9e7bb5f7551cea44a1ce72340b1ec67c3df754f942d218394b01265276f339fc0fc5b3e9a9d340497ede6cfbcaf4368128cf80ee2f02a584a1ed69d7103f0d1d51389d7621179cc88b1815f254421c19b28dc407e24eded0950d8d0dc82873b629b5ed33bc0d0bf16d3e4999e3af2414757a73538b25f181960071f25913dce08d400a2a3a513e3347db470cdc091f4232222da8ef1aadb009dabf36a0cf67a464f557c3a41c41d659d6d0adfe905b15759318c80ad60b02ba525b4e0196f75e2e9cec61f8e0f9b54443d641e69340a13804e79520c9d6198a715b3a1ea215f21171bb1d8d3b72d9179d68c2070d2f1d355905c57dff8eb79f8bf03ece4c14de866eb209f92bc62c40165a57b5f4f27c2abba3a7577bf8495e35b132b3bb56968f8cf1f7eb9cb6e4bd1b979b47f704fa071cada6a391145e5aade788393a07c0a0bbc78e9830ad8b9bcaea8a2365407b5f006268006d568ddc7b23cb70bd1374d79a3e37c736aa8625ca314be370e4f86226dbcde35d81fb942e6cb25ed756facb6d534f2d79172c18bfb8defd54589d27a99d2b69fbf8ccbdbf07f2e6b9931391f4f828493ac853a8e6806a4e6f835fa79b4e2be54eda216cb5791d5bdbfdc160b782fad9453</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 私人 </tag>
            
            <tag> 格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git速查手册</title>
      <link href="/posts/55090/"/>
      <url>/posts/55090/</url>
      
        <content type="html"><![CDATA[<h2 id="信息配置"><a href="#信息配置" class="headerlink" title="信息配置"></a>信息配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看全部配置信息</span></span><br><span class="line">git config --list</span><br><span class="line"><span class="comment"># 查看仓库配置信息</span></span><br><span class="line">git config --<span class="built_in">local</span> --list</span><br><span class="line"><span class="comment"># 查看系统信息配置</span></span><br><span class="line">git config --system --list</span><br><span class="line"><span class="comment"># 查看用户信息配置</span></span><br><span class="line">git config --global --list</span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个配置信息</span></span><br><span class="line">git config user.name</span><br><span class="line"><span class="comment"># 用户级别-信息配置（配置用户名）</span></span><br><span class="line">git config --global user.name <span class="string">&quot;hu1hu&quot;</span></span><br><span class="line"><span class="comment"># 用户级别-删除配置信息</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> user.name</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>以linux系统为例，系统信息全部用户通用，用户信息用户内通用（如root用户），仓库信息作用于一个仓库内。</li><li>若出现多条相同的配置信息，采用最后一条，采用范围最小的一条。</li><li>git配置是键值对的形式，同一级别同一个配置信息会覆盖原有的信息。</li><li>查看信息时，如果没有指定级别，则从local-&gt;global-&gt;system 向上找直到找到或没有</li><li>删除信息时，如果没有指定级别，则从local-&gt;global-&gt;system 向上找直到找到或没有，删除一条后即结束</li></ul><h3 id="必要的配置"><a href="#必要的配置" class="headerlink" title="必要的配置"></a>必要的配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般使用用户级别配置</span></span><br><span class="line"><span class="comment"># 配置用户名与用户邮箱</span></span><br><span class="line">git config --global user.name <span class="string">&quot;hu1hu&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;3261801992@qq.com&quot;</span></span><br><span class="line"><span class="comment"># 配置文件区分大小写</span></span><br><span class="line">git config --global core.ignore <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>用户名和邮箱记得配置成自己的，由于git会将每个提交（commit）与一个特定的作者关联起来，每次提交都会携带这些个人信息。</li></ul><h3 id="个人喜好配置"><a href="#个人喜好配置" class="headerlink" title="个人喜好配置"></a>个人喜好配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户级别配置</span></span><br><span class="line"><span class="comment"># 日志格式别名(使用 git lg 展示日志)</span></span><br><span class="line"><span class="comment"># log: 表示运行git log命令。</span></span><br><span class="line"><span class="comment"># --color: 启用彩色输出，使日志信息更易读。</span></span><br><span class="line"><span class="comment"># --graph: 在日志输出中显示分支图形，以便清楚地看到分支的合并和分支关系。</span></span><br><span class="line"><span class="comment"># --pretty=format:&#x27;...&#x27;: 定义日志输出的格式。%Cred、%Creset、%C(yellow)、%Cgreen、%C(bold blue)和%Creset是用于设置输出文本颜色的占位符，%h表# 示简短的提交哈希值，%d表示分支信息，%s表示提交消息，%cr表示相对提交时间，%an表示作者名字。</span></span><br><span class="line"><span class="comment"># --abbrev-commit: 使用缩写的提交哈希值，以便在日志信息中显示更简洁的提交标识。</span></span><br><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure><h3 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对所用域名配置代理</span></span><br><span class="line"><span class="comment"># 格式： git config --global http.proxy &lt;protocol&gt;://&lt;host&gt;:&lt;port&gt;</span></span><br><span class="line"><span class="comment"># 1、配置http代理，支持http/https 请求</span></span><br><span class="line">git config --global  http.proxy http://127.0.0.1:7890</span><br><span class="line"><span class="comment"># 2、配置https代理，支持https 请求,(要在代理服务器上配置SSL/TLS证书)</span></span><br><span class="line">git config --global  http.proxy http://127.0.0.1:7890</span><br><span class="line"><span class="comment"># 配置sockets5代理，通用型代理（会话层代理）</span></span><br><span class="line">git config --global  http.proxy sockets5://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定域名设置代理</span></span><br><span class="line"><span class="comment"># 格式：git config --global http.&lt;url&gt;.proxy &lt;protocol&gt;://&lt;host&gt;:&lt;port&gt;</span></span><br><span class="line"><span class="comment"># 配置http代理，支持http/https 请求</span></span><br><span class="line">git config --global  http.https://github.com.proxy http://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐使用指定域名的sockets5代理，可以配置多个</span></span><br><span class="line">git config --global http.https://github.com.proxy sockets5://127.0.0.1:7890</span><br><span class="line">git config --global http.https://gitlab.com.proxy sockets5://127.0.0.1:7890</span><br></pre></td></tr></table></figure><ul><li>当我们从github克隆仓库的时候可能会很慢，这时你就可能需要配置代理了。</li><li>记得把上面的端口号换成自己的。</li><li>参考：<a href="https://ericclose.github.io/git-proxy-config.html">一文让你了解如何为 Git 设置代理 - Eric (ericclose.github.io)</a></li></ul><h3 id="私有仓库克隆"><a href="#私有仓库克隆" class="headerlink" title="私有仓库克隆"></a>私有仓库克隆</h3><p>当我们需要克隆私有仓库时就需要执行登录操作，为了避免每次都需要输入用户（用户是邮箱）密码，我们可以进行相应的配置。</p><h4 id="SSH秘钥"><a href="#SSH秘钥" class="headerlink" title="SSH秘钥"></a>SSH秘钥</h4><p>将电脑中的公钥配置到github或gitee所需平台中</p><h4 id="使用凭据帮助器"><a href="#使用凭据帮助器" class="headerlink" title="使用凭据帮助器"></a>使用凭据帮助器</h4><p>第一次需要输入账号密码，以后会记住，默认开启使用系统自带的凭证管理器。虽然有进行加密，但是可能造成密码泄露。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8">Git - 凭证存储 (git-scm.com)</a></p><h4 id="使用Personal-Access-Token（访问令牌）"><a href="#使用Personal-Access-Token（访问令牌）" class="headerlink" title="使用Personal Access Token（访问令牌）"></a>使用Personal Access Token（访问令牌）</h4><p>等等</p><h2 id="仓库初始化"><a href="#仓库初始化" class="headerlink" title="仓库初始化"></a>仓库初始化</h2><h3 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入本地仓库的文件夹中</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>该命令会创建一个名为.git的子目录，这个子目录中包含初始化Git仓库的所用必须的文件。但是这时项目中的文件还没有被跟踪，仅仅做了初始化操作。</li></ul><h3 id="克隆已有仓库"><a href="#克隆已有仓库" class="headerlink" title="克隆已有仓库"></a>克隆已有仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;url&gt; [仓库本地要使用名字]</span><br><span class="line"><span class="comment"># 仓库名默认与远程一致</span></span><br></pre></td></tr></table></figure><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><!-- | 命令                                    | 功能                                             | workspace |      | staging |      | local repository |      | remote repository || --------------------------------------- | ------------------------------------------------ | --------- | ---- | ------- | ---- | :--------------: | ---- | ----------------- || git add <file>                          | 将工作区的文件放入暂存区，如果文件没有跟踪则跟踪 |           | →    |         |      |                  |      |                   || git commit -m "注释"                    | 将暂存区的文件夹提交到本地仓库                   |           |      |         | →    |    ↓版本更新     |      |                   || git commit -am "注释"                   | 将暂存区的文件追加到本地仓库                     |           | →    |         | →    |                  |      |                   || git reset --soft <>                     | 本地仓库分支回退                                 |           |      |         |      |    ↑版本回退     |      |                   || git reset --mixed <>                    | 本地仓库分支回退，并恢复到暂存区                 |           |      |         | ←    |    ↑版本回退     |      |                   || git reset --hard <>                     | 本地仓库分支回退，并恢复到暂存区与工作区         |           | ←    |         | ←    |    ↑版本回退     |      |                   || git restore <file>                      | 将暂存区的文件恢复到工作区                       |           | ←    |         |      |                  |      |                   || git restore --staged <file>             | 将HEAD指向版本恢复到暂存区                       |           |      |         | ←    |                  |      |                   || git rm <file>                           | 删除工作区、暂存区的文件                         | delete    |      | delete  |      |                  |      |                   || git rm --cached <file>                  | 删除暂存区的文件                                 |           |      | delete  |      |                  |      |                   || git fetch <remote> <branch>             | 将远程仓库拉取到本地仓库                         |           |      |         |      |                  | ←    |                   || git pull <remote> <远程分支>:<本地分支> |                                                  |           | ←    |         | ←    |                  | ←    |                   || git push                                |                                                  |           |      |         |      |                  | →    |                   | --><ul><li>git restore –staged <file> :默认从HEAD恢复，也可使用参数–source&#x3D;  指定版本。</li><li>git commit –amend -m “···”: 追加提交</li></ul><h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以查看仓库内的文件状态与一些建议，当不知道怎么办的时候可以使用</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p><strong>文件状态：</strong></p><ul><li>Untracked：未跟踪，没有交给git仓库管理</li><li>Unmodified：已跟踪，未修改（工作区与暂存区一致，与本地仓库一致）</li><li>Modified：已跟踪，已修改（工作区与暂存区不一致）</li><li>Staged：已跟踪，已缓存（工作区与暂存区一致，与本地仓库不一致）</li></ul><h2 id="查看历史提交记录"><a href="#查看历史提交记录" class="headerlink" title="查看历史提交记录"></a>查看历史提交记录</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原生</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 使用自定义，上面信息配置起了别名</span></span><br><span class="line">git lg</span><br></pre></td></tr></table></figure><h3 id="图形化git自带"><a href="#图形化git自带" class="headerlink" title="图形化git自带"></a>图形化git自带</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitk</span><br><span class="line"><span class="comment"># 解决中文乱码</span></span><br><span class="line">git config --global gui.encoding utf-8</span><br></pre></td></tr></table></figure><h2 id="修改最后一次的提交"><a href="#修改最后一次的提交" class="headerlink" title="修改最后一次的提交"></a>修改最后一次的提交</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.使用编辑器编辑上次提交信息</span></span><br><span class="line">git commit --amend</span><br><span class="line"><span class="comment"># 2.上次的提交信息被覆盖</span></span><br><span class="line">git commit --amend -m<span class="string">&quot;test&quot;</span>:</span><br></pre></td></tr></table></figure><h2 id="git-远程仓库操作"><a href="#git-远程仓库操作" class="headerlink" title="git 远程仓库操作"></a>git 远程仓库操作</h2><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote</span><br><span class="line"><span class="comment"># 使用-v，显示远程仓库简称与url</span></span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><h3 id="删除远程仓库"><a href="#删除远程仓库" class="headerlink" title="删除远程仓库"></a>删除远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove &lt;shortname&gt;</span><br><span class="line"><span class="comment"># git remote rm &lt;shortname&gt;</span></span><br></pre></td></tr></table></figure><h3 id="重命名远程仓库"><a href="#重命名远程仓库" class="headerlink" title="重命名远程仓库"></a>重命名远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rename &lt;old&gt; &lt;new&gt;</span><br></pre></td></tr></table></figure><h3 id="修改指定远程仓库的URL"><a href="#修改指定远程仓库的URL" class="headerlink" title="修改指定远程仓库的URL"></a>修改指定远程仓库的URL</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url &lt;remote_name&gt; &lt;new_url&gt;</span><br></pre></td></tr></table></figure><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>按两下<code>tab</code>键,当你只记住一部分操作的时候，这个操作有神奇的作用。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h3 id="新建本地分支"><a href="#新建本地分支" class="headerlink" title="新建本地分支"></a>新建本地分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch &lt;新分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># checkout是移动HEAD</span></span><br><span class="line">git checkout &lt;分支名&gt;</span><br><span class="line"><span class="comment"># 新版切换分支命令</span></span><br><span class="line">git switch &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge &lt;分支名&gt;</span><br><span class="line"><span class="comment"># 将分支合并到当前分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当有冲突时我们要处理冲突</span></span><br><span class="line"><span class="comment"># 1.手动处理</span></span><br><span class="line"><span class="comment"># 2.git add .</span></span><br><span class="line"><span class="comment"># 3.git commit</span></span><br><span class="line"><span class="comment"># 合并后把原来的分支删除</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://git-scm.com/doc"><a href="https://git-scm.com/book/zh/v2/">Git - Book (git-scm.com)</a></a></p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用指令</title>
      <link href="/posts/40863/"/>
      <url>/posts/40863/</url>
      
        <content type="html"><![CDATA[<h2 id="linux的目录结构"><a href="#linux的目录结构" class="headerlink" title="linux的目录结构"></a>linux的目录结构</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027214128.png" alt="image-20221027214128453"></p><ul><li><p><code>/</code>，根目录是最顶级的目录了</p></li><li><p><code>/bin</code>，bin是Binaries（二进制文件）的缩写，这个目录存放着最经常使用的命令</p></li><li><p><code>/dev</code>，dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><code>/etc</code>，etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p><code>/home</code>，用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p></li><li><p><code>/lib</code>，lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><code>/media</code>，linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></li><li><p><code>/mnt</code>，系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><code>/opt</code>，opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p><code>/proc</code>，proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件。</p></li><li><p><code>/root</code>，该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><code>/sbin</code>，s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></li></ul><ul><li><p><code>/var</code>，var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li><li><p><code>/usr</code>，usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></li></ul><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p><strong>ls命令</strong>是list的缩写，用来显示目标列表</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> [选项] [文件名]</span><br></pre></td></tr></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-l  <span class="comment"># 列表形式输出</span></span><br><span class="line">-h  <span class="comment"># 人性化输出</span></span><br><span class="line">-a  <span class="comment"># 输出全部文件（包括隐藏）</span></span><br><span class="line">-t  <span class="comment"># 按文件修改时间排序</span></span><br><span class="line">-S  <span class="comment"># 按文件大小排序</span></span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>目录：要显示列表的目录，也可以是具体的文件。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>不同颜色代表不同的文件类型</p><img src="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227234852652.png" alt="image-20231227234852652" style="zoom:70%;" /><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/linux/linux-tutorial.html">Linux 教程 | 菜鸟教程 (runoob.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="/posts/60565/"/>
      <url>/posts/60565/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日记</title>
      <link href="/posts/3jks09/"/>
      <url>/posts/3jks09/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="640e64b38f6604c63124af62c0a609b70637874930d378b09a04f166a92d4ea1">a63818ebb849064e381614be9ab2d9e7c3fd8042c6a7f496310400c5e6f170cc5dae2ad307934160bf013f8bbce9c53c0c88cade3877e0f4da20ed187da1918c387b553c2bf5b413c111d23644a7c995b19aabc2e6aa84a4d4ff1ac02b292e64125b0983d415182bcb73273f2c1458af0d2bad84fcdee56cc9ef1154870897594282ec5d0810b44190941c170ab1e235342c5d5fcd893ffd8f140f4a02763a16699545fa2b0c4dcde1f72c67dc1e1516eab793de4b384b1cb65a03f11930932dafb54e20c25edd7197ea968686b6b1168a32510e58ef9b230d826a3f10a526c5345cd9a69e922ad0cf736175c63c22665231d87c99f9c8f902b3e2520fd78a3a2d19287a989e555849dc61a5941711430a761ff145dca28fc715c728082593f98da343177ecddac2771e62e5ae28da31358dda32f4b81adf08194f88cf1d71fea84970d812da89d95efc089c0985cb53e212832125145eb2cd126d9106f0f32803d6d87bf2a882206338407d43196a54a9c22a229270f73b287dfcb80d430d74a95018ac119334c0df7c9818096e4b4f59f6a589b56aea1a35df97ba1c2d228f0a425d2b4a94e7ecfdf68314093649ee8d8c5c197e8eef2d9510731d1a0ff08fcbfc4dab36c2454b9cbffcd2ce86002820a07a0f08fba909b1daccfe4844b55fd8f938a5e1ecfa27949bcbaedc15eb52db30ef539a4bb7ecb056b925d12fe563e0b9afe9dcdaceac149127b6c99f531cc84ec975ea9b1578d04d0bc1a3119c798240fb258a8a8a5efe85098636ee1b067e688c117a55837d3f732b97928bec5f3dfebce799910d9a413772dff829e09a6ae1d19a3f6ee69605e4a0da4d41977a79124f635f75d98e62b45f86b6ffbb824fd5a95930dde2e261bb6cea8eb9210526272db8634db8f3985db9294b0f9737befdb31bfc5f75463cf0ef864d9f3f37db145e43e38bab6060dd4f347e2960b0e78649576a8e12f64e0b18e917b3f6975a7a282d5bc46d76e0bcabe4cda43464128377ea9353888ad3c6bab2d07fecb320ab4bb182ca98b42270e9fb0daf3fce88ffa8019b2d8a49dc87bdb1787a7409602753fd0dcdd629af64a8845909a9d319dcfc73dfd1acd705c27221193ce50fd3a846fabd87a8c6edabd2e9eb6d1733d9eb533c614e928ade103e29b8f0d78e5266c389780e90ccb7cc1852f88a38b7d534414eb688d0fa661889f46f54284abd04847b3e59ae5f49b413f565ca85d78dddc77b2ecc375537ba266175c5759543ce5e5d804004c744b114ac6bb5026a259c1e74ce35b86346258ae813343d5dbdbbdd7b2de1eba24a2e7cead96d56b5187740ff61a71340d4bae0351c3b01e1d9b6870e6cc48c791c19069850945955c2fbe2104bd8580ed2e299e6861056d4f64821c9020e7c1bcaba4dc5f5bb6c8cda24874b815358dd98aaa386951466ca98956580475b202d7eb82e804288de726da44a1d56b1b966d48bacf4ed4662ba88c3b94b4888417b59d9629d1768d06eea6667117d57815bbe7ec3fab701946f3871e917cef0659ddf55b580dde410de7821c105cc2dc94863976d0ff77526347faa7e049dee1d05925321b9c5ca3bc271efbb074f2003ec22b36c92a6b446efb285f634ca5fe99c815c7f34ca58acca6e2d4875a222d8e90880888ddaab1e24ad44f7bd38651302133b6d470d5c31332d297a1fd376dbad9a9602fc72c5e6b5a7d4f09eb090c9b68e8fad7bd35f27e3cf199cc54d60147921d52a71396c1c01b663526ccc4358efa5ddc4adb8e0332afe456ce19a7475c47b02ba23c1804e0731d3696fed044276e92a26ebfbfbe4ebae61d7a329dd3d34a2f73b4930955a96da9dfe6bce7774e7c9837bef5d6f9c95745bf72ffb90948a2b10e20a7b55a78eff5ce9be583f60f910e188390c955378663a515c3887b3b3d16053ea8891b1442120190342a6a9b9a7315fd30d3446a562bc60377a3efd70499d05d3668f72f83bd92c6c93feaaeb9f340bb541d4c7bd37b609d11fd047d1c07d3c6a0c5d179e2e9fecb7b809acffea2de5fb30f914025e000a926ce7e6823b710b92a112012b8b940226ba11e37b616d5801d9b8d3b46c1d1de89f977cb915b2c0e39e2a51dba8d9cbe5abac5dce46823413812436ec159fee422f246d04f6ba60e361df3759b17966cd59ac89823ed8e21c862c0d5bd1ff3043e4c039b702ee4fb4c628788580f146ac722ceecbbc62a8287e419ed10997c1594b8831c5a2d946f5efda29aeddb9d2de74158385541ae6719dec9967df440c78922c77be0408071bc64a4397d734a2cae58fd956f299e5a5329d3cd939c2d01d6ebc6e5f75dc26c3812cbe361b16fb15679ebf0850bafc01c8be18ba12f9eda06a733c1284614a6e68261b485d738d0060d821e1dcad701c7979c3a5b5925b943ae16f0e1acd2a4dc620a865cc5317fd015dce60a87167dccc57de244ee77c76b7fe2f2aac80e285ce69c8b99701503968bdebf4b0a96e47c952d0a63eb683ad282bc2bf5948752920e51978bfa5308863df51c07a605da0c32a4a0fbfec881aff1704573dacee9944da80fdb3a60d19105ab1b29d17164d97a1ce07527a6457cce6006519e07943693367533a481ca60a4ca4a16592b1e8375ac7aff57d02f9074300f2cb0c70b79814733240d6b19df6a39e74e2deb700154097fd2efd09f8b8eaae2baccad92235905e5d22f6c1a839af62c5542cdd483ece39bc30f7fcb233b7abcc1b2dbc0fad62975a88598a3442f888f5452c57b9e71655f3459c251786ea60f4b1be898f2a53baaa605d9dc94ddf7fafe80b90a658938f3a73437e860251dc1151530b48d399f905bfaeae21e67af631084a57da413daf7829757bedc8af2678c6ac4fcb0c38834b1257608f1d2b91e9689b33922c958ee173be25738e9097a2d904ee4a24f7479e84f0642691b039c4a81f74d4cf7cf5b2e2f4fa704d8fff40c800499c9896388dc3e0349fa89a640530b046efc815b12ec06845b994636a26e833aed779c529b4885a4fa8c014728818b4ea0e97022580816588a95e6d13468b01b312621d01392ede21f644cb4ec2c9ede5646495d56c77ea6fb62c6fa0b090db32f12420d779f3565ad33b55206bd6a3ba56676aecf18576297dcc2ea9f3ce83aa78ab172df61e4779f0f814c5eaf891fd37a04eaf1a5c9cb38937dbf2966f9d4220174eeb91b889ce81cca0905048a3711b8e795a6aee144c99323aea5d5d35ccde15028072d45893712f180ecdd2383836216d00b1676e1897d455570ebcf92c882ba2d421fb9e5b5e800fbaae99ec699bffe7a4ed7fac1bd41d4cde064ea3603f477b6ad04704a981080f3cae1afce2af0866e17ca9137db70206df51773ef60286ea2e97022b27dfd6592cfd1a4593a57260b987369d190ff3da9226546146af5d5c4412df292274d839797a55656f3602884d0894901a1229af55fe90303b38dd6ed1eb6e824f7554cc89ec93f37b2d9fe83dee46b4302fd5f83873a4ee7f640efdf9dddb031b58b15aff4a55d5316077e077db30299ab9abace3350ad2253d5d71abcf495a1b3fba9ed04299859adddd272ad50ec3a79ebabeda484ffd3793f4d93dc3496591f9781c2cfb446ff3ad030fca59605131ff758c71d4d11138e9e791d2cbcc0bd9275d15b997ca4a4518760566a682340670e757f3303d8fd48b866241b86871e843a7bea7f6d0968f5d1e7c2172e8ee1266545f161cb369f00bb2a979f24d4aa8574b36958c56633e9df10fe084f264a35136c80b7d540af7ec85cfebbfc1e4bef735996ec9da7aa8c8d9634f025c1c545b657d310f9034f030ca600e8b53e7f69ac111dc9e4bf156cb1cb86093918c32b154368a5212f73a8d20a5495aa654c02bb06e542c1a4f0cb9320d22360d972c1fa9fee17dac7cdb1c6937581df04fdb60f1798119ed6e7d26b600cf72fd0950e293de03803b518fdf501b39f276646d88726bb96198e569e6052159d3de5bd5da0f4aae5124c8f8a43cafc0f39b4190bdec71953d23c5bdb353a6c3f27cc79ca3d82012a69596eab4f74a056cb0261feaa60432058cee8a4b4dbe6177d399d0b078cc7a4e7dca5de280ad7053a7d683601a42641a0776ab0779677b417987ab0b81cdeb8fb94c34f5867bd79aed31ea9ba57f275d7f91059459f0d88bceb4d726a539b3138d46ef029d3cb1237ed11688481f893d1b38b6838bfc00fbf64f9bfd1905841a27026809439f61e1aedc2d145e458b8cdd243525b6d17a03699319cb43a03d515cac6d952a142cad5e78836937fb91ada103ef29a3536b480ca53bbdf4612416372a58bc6ebea4aac2bea8a18e34d270e82a14ccd7f6271631783ef130efc9fc0e75fcb1349c4f11c90d543e5acff09672ae81da7feabccad3b0dee259eccff6a946e163db6d76ad83d5c32e5e1b34a9f71f618c05c0c35502508818a145eca5adf09bac351d2ef50ca01670f44795700ad837b8539536a3c946aed0f4f6b92312e3aeddd09693cb6ef93690d39ee089fbe0eb686dad4ffd14bbd17c800bae61f543c6ef6dfc925fe0e3e94237c33feada1bfaf7dcb42e57d29082c1ec07bad991415b678865b0cb79e2d4443eeca286f69cd476d208685472b11b2f05fa70939196296cfd05d394fb7641f59093867d59ed06d478d24117f1bfdfde230eb656bbc73bd400ab3f5d6475c749a95a506ca33e701333d32661577971a31cc52335656bc850d8257b5b78d7543fa198bf1190f0820d1044f84712895f59ce3ff7585b424256ccc78debf017e35fe4621726e719b2a66db2cbb0994b79336d1d0193243e820d7ccd8f6e01e5447a6ef5465ef18e3142aa369b83b0da3f9932ffd2cb52bf39312bf08cce7ad8aa5550641f869ca5554f03817539421d93d9120886ce01a22b36b1207af408dc0e51fa27e58fb0c29ac8a4ed92dd83c85377e44da8a199b6e8e3c8c8974d717043f6eb923ef15db6be8d3dcdd510f74d387a571b137d859a0eff8d54103f34e81cd57c43330bafdb27913cf1829ca6bc19e043195076de9e296acb518c343ee28c08d1902f7a654fd0382861fa6d696be25ff21459679b3c443bf636d945b66dceeb62e495d3ca02bc3d71741aeb9c1515501ddc81213adab911f4d89231b572697a844121e9a602ac777e09726123301191cb3504cf5a0747db3580ecbc6944da5ce8daeaeaeef1ba3296f7e0cbe51d0145f2668c4456d4f48d8d6d6a4e2b2e2405ea9a54112167e30f48df4ee8c29aa3465c060f162bd04c50d5b89a0db854b97393b263c249b3e1b3e9742233a03e29ccd68963ac3e3ccad566fdb53ea931dddb9ae461083541d25e5a1dce460d471641ae8cb3ae789a7066abd7a2665d51878e8e824e352298618228617abf0dbea9bb7997bb9826fa810f6455a2b1807359ee85b8b66e76189bc808acd70fe79eb39175447c3d7fb3cd956b44691bac6c2d3bccd49d61ebda142f43c478990185a673e905d5b18d34575e8d355e9eb121a049f54a440e38003563392a1d84ab721a6beb79d567c933176a48e0741584831781cd72bb55486bf34e6fbadde9a8a379387de22c48f893e541c7941f6bd824970540482cf7f2fc0ee25c0eb7271e9bd3a8c3e6fd50d5f5b6141f3896f3bfba673197cfff3cd5f383b546734b4e888f1ab401b8576c919fe6fc28b7fb6f9bf35b2921a44f2c9693e92c0d68c990037b3c7c7584a870cdcb26834c725471</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 私人 </tag>
            
            <tag> 格式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
