<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>软件工程复习 | hu1hu的博客</title><meta name="author" content="hu1hu,3261801992@qq.com"><meta name="copyright" content="hu1hu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="软件与软件工程介绍软件的概念、特性和分类 软件的概念：软件是计算机系统中与硬件相互依存的另一部分，包括程序、数据及其相关文档的完整集合  程序：程序是按事先设计的功能和性能要求执行的指令序 列;  数据：数据是使程序能够正确地处理信息的数据结构;  相关文档：文档是与程序开发、维护和使用有关的图 文材料。    软件的特性 形态特性、智能特性、开发特性、质量特性、生产特性、管理特性、环境特性、维护">
<meta property="og:type" content="article">
<meta property="og:title" content="软件工程复习">
<meta property="og:url" content="https://www.hu1hu.top/posts/ishdl67348h/index.html">
<meta property="og:site_name" content="hu1hu的博客">
<meta property="og:description" content="软件与软件工程介绍软件的概念、特性和分类 软件的概念：软件是计算机系统中与硬件相互依存的另一部分，包括程序、数据及其相关文档的完整集合  程序：程序是按事先设计的功能和性能要求执行的指令序 列;  数据：数据是使程序能够正确地处理信息的数据结构;  相关文档：文档是与程序开发、维护和使用有关的图 文材料。    软件的特性 形态特性、智能特性、开发特性、质量特性、生产特性、管理特性、环境特性、维护">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.jpg">
<meta property="article:published_time" content="2024-01-03T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-05T11:26:34.545Z">
<meta property="article:author" content="hu1hu">
<meta property="article:tag" content="软件工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.hu1hu.top/posts/ishdl67348h/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '软件工程复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-05 19:26:34'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/header-numbering.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fa fa-paper-plane"></i><span> 导航栏</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/软件工程.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="hu1hu的博客"><span class="site-name">hu1hu的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fa fa-paper-plane"></i><span> 导航栏</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">软件工程复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-03T16:00:00.000Z" title="发表于 2024-01-04 00:00:00">2024-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-05T11:26:34.545Z" title="更新于 2024-01-05 19:26:34">2024-01-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B6%E5%AE%83/">其它</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="软件工程复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="软件与软件工程介绍"><a href="#软件与软件工程介绍" class="headerlink" title="软件与软件工程介绍"></a>软件与软件工程介绍</h2><h3 id="软件的概念、特性和分类"><a href="#软件的概念、特性和分类" class="headerlink" title="软件的概念、特性和分类"></a>软件的概念、特性和分类</h3><ol>
<li><p><strong>软件的概念</strong>：软件是计算机系统中与硬件相互依存的另一部分，包括<strong>程序</strong>、<strong>数据</strong>及其<strong>相关文档</strong>的完整集合</p>
<ul>
<li><p><strong>程序</strong>：程序是按事先设计的功能和性能要求执行的<strong>指令序 列</strong>;</p>
</li>
<li><p><strong>数据</strong>：数据是使程序能够正确地处理信息的数据结构;</p>
</li>
<li><p><strong>相关文档</strong>：文档是与程序开发、维护和使用有关的图 文材料。</p>
</li>
</ul>
</li>
<li><p><em>软件的特性</em></p>
<p>形态特性、智能特性、开发特性、质量特性、生产特性、管理特性、环境特性、维护特性、废弃特性、应用特性</p>
</li>
<li><p>软件的分类</p>
<p>系统软件、支撑软件（工具软件）、应用软件、可复用软件</p>
</li>
</ol>
<h3 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h3><blockquote>
<p>20世纪60年代，计算机已经应用在很多行业，解决问题的规模及难度逐渐增加，由于软件本身的特点及软件开发方法等多方面问题，软件的发展速度远远滞后于硬件的发展速度，不能满足社会日益增长的软件需求。软件开发周期长、成本高、质量差、维护困难，导致20世纪60 年代末软件危机的爆发。</p>
</blockquote>
<p>除去软件本身的特点外，软件危机的原因还有以下几点：</p>
<ol>
<li>缺乏软件开发的经验和有关软件开发数据的积累，使得开发工作的计划很难制定。</li>
<li>软件人员与用户的交流存在障碍，除了知识背景的差异，缺少合适的交流方法及需求描述工具也是一个重要的原因。</li>
<li>软件开发过程不规范，缺少方法论和规范的指导，开发人员各自为战。</li>
<li>随着软件规模的增大，其复杂性往往会呈指数级升高。</li>
<li>缺少有效的软件评测手段，提交用户的软件质量差。</li>
</ol>
<h3 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h3><blockquote>
<p>为了克服软件危机，1968年10月在北大西洋公约组织（NATO）召开的计算机科学会议上，Fritz Bauer首次提出“软件工程”的概念，试图将工程化方法应用于软件开发。</p>
<p>许多计算机和软件科学家尝试，把其他工程领域中行之有效的工程学知识运用到软件开发工作中来。经过不断实践和总结，最后得出一个结论:按工程化的原则和方法组织软件开发工作是有效的，是摆脱软件危机的一条主要的出路。</p>
<p>我国2006 年的国家标准GB&#x2F;T11457—2006《软件工程术语》中对软件工程的定义为: “<strong>应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的 软件产品的定义、开发、发布和维护的工程或进行研究的学科。</strong>”</p>
</blockquote>
<p><em>概括地说，<strong>软件工程</strong>是指导软件<strong>开发</strong>和<strong>维护</strong>的工程性学科，主要思想在于强调在软件开发过程中应用工程化原则的重要性。</em></p>
<ol>
<li><strong>软件工程的目标</strong><ol>
<li><strong>软件的质量特性</strong>：功能性、可靠性、易用性、效率、维护性和可移植性。</li>
<li><strong>软件工程的目标</strong>是运用先进的<strong>软件开发技术</strong>和<strong>管理方法</strong>来提高<strong>软件的质量和生产率</strong>,也就是要以较短的周期、较低的成本生产出高质量的软件产品，并最终实现软件的工业化生产。</li>
</ol>
</li>
<li>软件工程的基本原理<ul>
<li>用分阶段的生命周期计划严格管理</li>
<li>坚持进行阶段评审</li>
<li>实行严格的产品控制</li>
<li>采用现代程序设计技术</li>
<li>结果应能清楚地审查</li>
<li>开发小组的人员应该少而精</li>
<li>承认不断改进软件工程实践的必要性</li>
</ul>
</li>
</ol>
<h3 id="软件生存期"><a href="#软件生存期" class="headerlink" title="软件生存期"></a>软件生存期</h3><p><strong>概念：</strong></p>
<blockquote>
<p>软件也有一个孕育、诞生、成长、成熟和衰亡的生存过程，我们称这个过程为<strong>软件生命周期</strong>或<strong>软件生存期</strong>。</p>
</blockquote>
<p><strong>软件生存期</strong>又称软件生命周期，由<strong>软件定义</strong>、<strong>软件开发</strong>、<strong>运行维护</strong>三个时期组成。</p>
<ul>
<li><strong>软件定义时期</strong>的主要任务是解决“做什么”的问题。</li>
<li><strong>软件开发时期</strong>的主要任务是解决“如何做”的问题。</li>
<li><strong>运行维护时期</strong>的主要任务是使软件持久地满足用户的需要。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">  subgraph  </span><br><span class="line">    软件生命周期 --&gt; 软件定义</span><br><span class="line">    subgraph  </span><br><span class="line">    软件定义 --&gt; 问题定义</span><br><span class="line">    软件定义 --&gt; 可行性研究</span><br><span class="line">    软件定义 --&gt; 需求分析</span><br><span class="line">    end</span><br><span class="line">    软件生命周期 --&gt; 软件开发</span><br><span class="line">    subgraph  </span><br><span class="line">    软件开发 --&gt; 概要设计</span><br><span class="line">    软件开发 --&gt; 详细设计</span><br><span class="line">    软件开发 --&gt; 编码</span><br><span class="line">    软件开发 --&gt; 测试</span><br><span class="line">    end</span><br><span class="line">    软件生命周期 --&gt; 运行维护</span><br><span class="line">    subgraph  </span><br><span class="line">    运行维护 --&gt; 改正性维护</span><br><span class="line">    运行维护 --&gt; 适应性维护</span><br><span class="line">    运行维护 --&gt; 完善性维护</span><br><span class="line">    运行维护 --&gt; 预防性维护</span><br><span class="line">    end</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

<p><strong>各阶段耗时比例：</strong></p>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226210241938.png" alt="image-20231226210241938" style="zoom:40%;" />





<h4 id="软件定义"><a href="#软件定义" class="headerlink" title="软件定义"></a>软件定义</h4><h5 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h5><ul>
<li><p>关键问题是：“<strong>要解决的问题是什么</strong>”。</p>
</li>
<li><p>提交的内容为关于问题性质、工程目标和工程规模的书面报告。</p>
</li>
</ul>
<h5 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h5><ul>
<li><p>回答的关键问题是：“<strong>上一个阶段所确定的问题是否有行得通的解决办法</strong>”。</p>
</li>
<li><p>提交的内容为可行性研究报告，即从技术、经济和社会因素等方面研究各方案的可行性。</p>
</li>
</ul>
<h5 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h5><ul>
<li><p>对用户提出的要求进行分析并给出详细的定义。</p>
</li>
<li><p>准确地回答“<strong>目标系统必须做什么</strong>”这个问题。也就是对目标系统提出完整、准确、清晰、具体的要求。</p>
</li>
<li><p>编写<strong>软件需求说明书</strong>或<strong>系统功能说明书</strong>及<strong>初步的系统用户手册</strong>。</p>
</li>
<li><p>提交管理机构<strong>评审</strong>。</p>
</li>
</ul>
<h4 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h4><ul>
<li><strong>任务</strong>：具体设计和实现前一个时期即软件定义时期定义的软件。</li>
<li><strong>执行人</strong>：系统设计员，高级程序员，程序员，测试工程师和辅助人员等</li>
<li><strong>阶段划分</strong>：分为概要设计、详细设计、编码和单元测试、集成测试和系统测试。其中前两个阶段又称为系统设计，后两个阶段又称为系统实现。</li>
</ul>
<h5 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h5><ul>
<li><p>概括地回答“怎样实现目标系统?”。</p>
</li>
<li><p>设计程序的体系结构，也就是确定程序由哪些模块组成以及模块间的关系。</p>
</li>
<li><p>提交的文档是概要设计说明书。</p>
</li>
</ul>
<h5 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h5><ul>
<li><p>回答“应该怎样具体地实现这个系统”。</p>
</li>
<li><p>详细地设计每个模块，确定实现模块功能所需要的算法和数据结构。</p>
</li>
<li><p>提交的文档是软件的详细设计说明书。</p>
</li>
</ul>
<h5 id="程序编码和单元测试"><a href="#程序编码和单元测试" class="headerlink" title="程序编码和单元测试"></a>程序编码和单元测试</h5><ul>
<li><p>写出正确的容易理解、容易维护的程序模块。</p>
</li>
<li><p>提交的文档为源程序、详尽的程序说明和单元测试报告。</p>
</li>
</ul>
<h5 id="集成测试和系统测试"><a href="#集成测试和系统测试" class="headerlink" title="集成测试和系统测试"></a>集成测试和系统测试</h5><ul>
<li><p>通过各种类型的测试(及相应的调试)使软件达到预定的要求。</p>
</li>
<li><p>提交的文档为测试计划、详细测试方案以及实际测试结果等。</p>
</li>
</ul>
<h4 id="运行维护"><a href="#运行维护" class="headerlink" title="运行维护"></a>运行维护</h4><p>主要任务是使软件<strong>持久地</strong>满足用户的需要，通常有4类维护活动：</p>
<ul>
<li><p><strong>改正性维护</strong>，也就是诊断和改正在使用过程中发现的软件错误；</p>
</li>
<li><p><strong>适应性维护</strong>，即修改软件以适应环境的变化；</p>
</li>
<li><p><strong>完善性维护</strong>，即根据用户的要求改进或扩充软件，使它更完善；</p>
</li>
<li><p><strong>预防性维护</strong>，即修改软件为将来的维护活动预先做准备。</p>
</li>
</ul>
<h4 id="典型文档"><a href="#典型文档" class="headerlink" title="典型文档"></a>典型文档</h4><ul>
<li><p><strong>软件需求规格说明书</strong>：描述将要开发的软件做什么。</p>
</li>
<li><p><strong>项目计划</strong>：描述将要完成的任务及其顺序，并估计所需要的时间及工作量。</p>
</li>
<li><p><strong>软件测试计划</strong>：描述如何测试软件，使之确保软件应实现规定的功能，并达到预期的性能。</p>
</li>
<li><p><strong>软件设计说明书</strong>：描述软件的结构，包括概要设计及详细设计。</p>
</li>
<li><p><strong>用户手册</strong>：描述如何使用软件。</p>
</li>
</ul>
<h3 id="软件工程化方法概论"><a href="#软件工程化方法概论" class="headerlink" title="软件工程化方法概论"></a><strong>软件工程化方法概论</strong></h3><blockquote>
<p>通常把软件开发生命周期全过程中使用的一整套技术的集合称为方法学（methodology)，也称为范型（paradigm)。在软件工程范畴中，这两个词的含义基本相同。</p>
</blockquote>
<p><strong>软件工程方法学</strong>包含三个要素:<strong>方法</strong>、<strong>工具</strong>和<strong>过程</strong>。</p>
<ul>
<li><strong>软件工程方法（method）</strong>为建造软件提供技术上的解决方法（“如何做”）。目前使用得最广泛的方法是传统方法（结构化方法）和面向对象的方法。</li>
<li><strong>工具</strong>为方法的运用提供自动的或半自动的软件支撑环境，如CASE（Computer Aided Soft-ware Engineering)工程</li>
<li><strong>过程</strong>是获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤</li>
</ul>
<h2 id="软件生存期模型"><a href="#软件生存期模型" class="headerlink" title="软件生存期模型"></a>软件生存期模型</h2><h3 id="瀑布模型（文档驱动）"><a href="#瀑布模型（文档驱动）" class="headerlink" title="瀑布模型（文档驱动）"></a>瀑布模型（文档驱动）</h3><h4 id="传统的瀑布模型"><a href="#传统的瀑布模型" class="headerlink" title="传统的瀑布模型"></a>传统的瀑布模型</h4><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226211944358.png" alt="image-20231226211944358" style="zoom:40%;" />

<p><strong>特点</strong></p>
<ol>
<li><strong>阶段间具有顺序性和依赖性</strong>。其中包含两重含义：<ol>
<li>必须等前一阶段的工作完成之后，才能开始后一阶段的工作</li>
<li>前一阶段的输出文档就是后一阶段的输入文档</li>
</ol>
</li>
<li><strong>推迟实现</strong>的观点：<ol>
<li>瀑布模型在编码之前设置了系统分析和系统设计的各个阶段，分析与设计阶段的基本任务规定，在这两个阶段主要考虑目标系统的逻辑模型，不涉及软件的物理实现。</li>
<li>清楚地区分逻辑设计与物理设计，尽可能推迟程序的物理实现，是按照瀑布模型开发软件的一条重要的指导思想。</li>
</ol>
</li>
<li><strong>质量保证</strong>的观点：<ol>
<li>每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。</li>
<li>每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误。</li>
</ol>
</li>
</ol>
<h4 id="实际的瀑布模型"><a href="#实际的瀑布模型" class="headerlink" title="实际的瀑布模型"></a>实际的瀑布模型</h4><ul>
<li><p>实际的瀑布模型是“反馈环”的，如图所示。</p>
</li>
<li><p>图中实线箭头表示开发过程，虚线箭头表示维护过程。</p>
</li>
</ul>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226212540631.png" alt="image-20231226212540631" style="zoom:40%;" />

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>可强迫开发人员采用规范化的方法。</p>
</li>
<li><p>严格地规定了每个阶段必须提交的文档。</p>
</li>
<li><p>要求每个阶段交出的所有产品都必须是经过验证的。</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要。如果需求规格说明与用户需求之间有差异，就会发生这种情况。</p>
</li>
<li><p>瀑布模型只适用于项目开始时需求已确定的情况。</p>
</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>需求明确、较大型系统、开发周期不紧张</li>
</ul>
<h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><blockquote>
<p>快速原型是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。</p>
</blockquote>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226214218092.png" alt="image-20231226214218092" style="zoom:40%;" />

<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>探索型原型</strong></p>
<blockquote>
<p>这种类型的原型是把原型用于开发的需求分析阶段，目的是要型清用户的需求，确定所期望的特性，并探索各种方案的可行性。它主要针对开发目标模糊，用户与开发都对项目都缺乏经验的情况，通过对原型的开发来明确用户的需求。</p>
</blockquote>
<p><strong>实验型原型</strong></p>
<blockquote>
<p>这种原型主要用于设计阶段，考核；实现方案是否合适，能否实陋。对于一个大型系统，若对设计方案心中没有把握时，可通过这种原型来证实设计方案的正确性</p>
</blockquote>
<p><strong>演化型原型</strong></p>
<blockquote>
<p>这种原型主要用于及早向用户提交一个原型系统，该原型系统或者包含系统的框架，或者包含系统的主要功能，在得到用户的认可后，将原型系统不断扩充演变为最终的软件系统。它将原型的思想扩展到软件开发的全过程。</p>
</blockquote>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>有助于满足用户的真实需求。</p>
</li>
<li><p>原型系统已经通过与用户的交互而得到验证，据此产生的规格说明文档能够正确地描述用户需求。</p>
</li>
<li><p>软件产品的开发基本上是按线性顺序进行。</p>
</li>
<li><p>因为规格说明文档正确地描述了用户需求，因此，在开发过程的后续阶段不会因为发现规格说明文档的错误而进行较大的返工。</p>
</li>
<li><p>开发人员通过建立原型系统已经学到了许多东西，因此，在设计和编码阶段发生错误的可能性也比较小，这自然减少了在后续阶段需要改正前面阶段所犯错误的可能性。</p>
</li>
<li><p>快速原型的突出特点是“快速”。开发人员应该尽可能快地建造出原型系统，以加速软件开发过程，节约软件开发成本。</p>
</li>
</ul>
<p>​	<strong>原型的用途是获知用户的真正需求，一旦需求确定了，原型可以抛弃，当然也可以在原型的基础上进行开发。</strong></p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>准确原型设计困难</li>
<li>原型理解可能不同</li>
<li>不利于开发人员创新</li>
</ul>
<h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><ul>
<li><p>增量模型也称为渐增模型，是Mills等于1980年提出来的。</p>
</li>
<li><p>使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。</p>
</li>
<li><p>每个构件由多个相互作用的模块构成，并且能够完成特定的功能。</p>
</li>
</ul>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231226214519036.png" alt="image-20231226214519036" style="zoom:40%;" />

<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>能在较短时间内向用户提交可完成一些有用的工作产品，即从第1个构件交付之日起，用户就能做一些有用的工作。</li>
<li>逐步增加产品的功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给用户组织带来的冲击。</li>
<li>项目失败的风险较低，虽然在某些增量构件中可能遇到一些问题，但其他增量构件将能够成功地交付给客户。</li>
<li>优先级最高的服务首先交付，然后再将其他增量构件逐次集成进来。因此，最重要的系统服务将接受最多的测试。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>增量构件划分以及集成困难</li>
<li>容易退化为边做边改模型</li>
</ul>
<h3 id="螺旋模型（风险驱动）"><a href="#螺旋模型（风险驱动）" class="headerlink" title="螺旋模型（风险驱动）"></a>螺旋模型（风险驱动）</h3><blockquote>
<p>在每个阶段之前都增加了风险分析过程的快速原型模型</p>
</blockquote>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231227205233935.png" alt="image-20231227205233935" style="zoom:50%;" />

<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li>利于把软件质量作为软件的开发目标</li>
<li>减少测试</li>
<li>维护和开发不分开</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>风险估计困难</li>
</ul>
<h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><h3 id="敏捷开发方法与极限编程"><a href="#敏捷开发方法与极限编程" class="headerlink" title="敏捷开发方法与极限编程"></a>敏捷开发方法与极限编程</h3><p><strong>敏捷开发：</strong></p>
<ul>
<li>强调人与人之间的沟通。</li>
<li>轻文档（弱化文档，但不是不需要文档）</li>
<li>客户需要全程参与</li>
<li>需求可以的变化</li>
</ul>
<p><strong>极限编程（Extreme Programming，XP）：</strong></p>
<ol>
<li>用户故事（User Stories）：以用户的视角描述软件功能和需求。</li>
<li>迭代开发：将开发过程划分为短小的迭代周期，并在每个周期内交付可用的软件。</li>
<li>快速反馈：通过频繁的客户反馈和自动化测试，及早发现和解决问题。</li>
<li>集体所有权（Collective Ownership）：团队成员共同拥有代码和系统，鼓励共同协作和责任。</li>
<li>持续集成（Continuous Integration）：团队成员频繁地将代码集成到共享代码库中，并进行自动化测试和构建。</li>
<li>可持续性（Sustainability）：注重团队成员的健康、工作量的平衡和可持续的开发节奏。</li>
</ol>
<h4 id="敏捷原则"><a href="#敏捷原则" class="headerlink" title="敏捷原则"></a>敏捷原则</h4><p>(1)我们最优先要做的是通过尽早、持续交付有价值的软件来使客户满意。</p>
<p>(2)即使在开发的后期，也欢迎需求变更。敏捷过程利用变更为客户创造竞争优势。</p>
<p>(3)经常交付可运行软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。</p>
<p>(4)在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。 </p>
<p>(5)围绕有积极性的个人构建项目。给他们提供所需的环境和支持，并且信任他们能够完成工作。</p>
<p>(6)在团队内部，最富有效果和效率的信息传递方法是面对面交谈。</p>
<p>(7)可运行软件是进度的首要度量标准。</p>
<p>(8)敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够保持一种长期、稳定的开发速度。</p>
<p>(9)不断地关注优秀的技能和好的设计会增强敏捷能力。</p>
<p>(10)简单是必要的。</p>
<p>(11)好的架构、需求和设计出自于自组织团队。</p>
<p>(12)每隔一定时间，团队会反省如何才能更有效地工作，并相应调整自己的行为。</p>
<h3 id="CMM-CMMI"><a href="#CMM-CMMI" class="headerlink" title="CMM&#x2F;CMMI"></a>CMM&#x2F;CMMI</h3><h4 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h4><blockquote>
<p>CMM（Capability Maturity Model for Software）软件能力成熟度模型。</p>
</blockquote>
<p>　　<strong>1.初始级(initial)</strong></p>
<p>　　工作无序，项目进行过程中常放弃当初的规划</p>
<p>　　管理无章，缺乏健全的管理制度</p>
<p>　　开发项目的成效不稳定，产品的性能和质量依赖于个人能力和行为。</p>
<p>　　<strong>2.可重复级(Repeatable)</strong></p>
<p>　　管理制度化，建立了基本的管理制度和规程，管理工作有章可循</p>
<p>　　初步实现标准化，开发工作较好的实施标准</p>
<p>　　稳定课跟踪，新项目的计划和管理基于过去的实践经验，具有重复以前成功项目的环境和条件</p>
<p>　　<strong>3.已定义级(Defined)</strong></p>
<p>　　开发的过程，包括技术工作和管理工作，均已实现标准化，文档化。</p>
<p>　　建立了完善的培训制度和专家评审制度</p>
<p>　　全部技术活动和管理活动均可稳定实施</p>
<p>　　项目的质量，进度和费用均可控制。</p>
<p>　　对项目进行中的过程，岗位和指责均有共同的理解。</p>
<p>　　<strong>4.已管理级(Managed)</strong></p>
<p>　　产品和过程已建立了定量的质量目标。</p>
<p>　　过程中活动的生产率和质量是可度量的。</p>
<p>　　已建立过程数据库。</p>
<p>　　已实现项目产品和过程的控制</p>
<p>　　可预测过程和产品质量趋势。</p>
<p>　　<strong>5.优化级(Optimizing)</strong></p>
<p>　　可集中精力改进过程，采用新技术，新方法。</p>
<p>　　拥有防止出现缺陷，识别薄弱环节以及加以改进的手段</p>
<p>　　可取得过程有效性的统计数据，并可据此进行分析，从而得到更佳方法。</p>
<h4 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h4><p>CMMI（Capability Maturity Model Integration）软件成熟度模型集成。CMMI是CMM模型的最新版本。</p>
<p>CMMI认证一共有5个级别，CMMI1级，初始级；CMMI2级，已管理级；CMMI3级，已定义级；CMMI4级，已量化管理级；CMMI5级，优化级</p>
<h2 id="软件需求获取与结构化分析"><a href="#软件需求获取与结构化分析" class="headerlink" title="软件需求获取与结构化分析"></a>软件需求获取与结构化分析</h2><h3 id="需求获取的任务和原则"><a href="#需求获取的任务和原则" class="headerlink" title="需求获取的任务和原则"></a>需求获取的任务和原则</h3><p><strong>需求获取的任务</strong></p>
<ol>
<li>发现和分析问题，并分析问题的原因&#x2F;结果关系。</li>
<li>与用户进行各种方式的交流，并使用调查研究方法收集信息。</li>
<li>按照三个成分观察问题的不同侧面、即数据、过程和接口</li>
<li>将获取的需求文档化，形式有用例、决策表、需求表等</li>
</ol>
<p><strong>需求获取的原则</strong></p>
<ol>
<li><strong>深入浅出的原则。</strong>就是说，需求获取要尽可能全面、细致。获取的需求是个全集，目标系统真正实现的是个子集。</li>
<li><strong>以流程为主线的原则。</strong>在与用户交流的过程中，应该用流程将所有的内容串起来。如信息、组织结构、处理规则等。这样便于交流沟通。流程的描述既有宏观描述，也有微观描述。</li>
</ol>
<hr>
<p>可以把软件需求分析阶段的工作分为4个步骤，即<strong>获取需求</strong>、<strong>分析需求</strong>、<strong>定义需求</strong>和<strong>验证需求</strong>。</p>
<ol>
<li><p><strong>需求获取</strong></p>
<p>通过启发、引导从客户（或用户）那里得到的原始需求是他们的业务要求（needs），简称为N。这是分析之前获取的需求，其中可能存在一些实际问题，这些问题只有通过分析才能得到解决，直接把获取的需求作为软件设计阶段的依据将会导致严重的后果。 </p>
</li>
<li><p><strong>分析需求</strong></p>
<p>认真研究获取的需求，必须考虑以下几方面：<br>   (1) <strong>完整性</strong>：每项获取的需求都应给出清楚的描述，使得软件开发工作能够取得设计和实现该功能所需要的全部必要信息。<br>   (2) <strong>正确性</strong>：获取的每项需求必须是准确无误的，并且需求描述无歧义性。<br>   (3) <strong>合理性</strong>：各项需求之间、软件需求与系统需求之间应是协调一致的，不应存在矛盾和冲突。</p>
<p>   (4) <strong>可行性</strong>：包括技术可行性 、经济可行性 、社会可行性 。<br>   (5) <strong>充分性</strong>：获取的需求是否全面、周到。 </p>
<p>由于分析的过程会对获取的需求做部分调整，也即从获取的需求N中去掉了一些a，又补充了一些c，从而得到的是分析的需求R1（b+c）。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231229103820903.png" alt="image-20231229103820903"></p>
</li>
<li><p><strong>定义需求</strong></p>
<p>​    将已经过分析的需求清晰、全面、系统、准确地描述成为正式的文档，这一步定义需求的工作就是编写需求规格说明。 </p>
</li>
<li><p><strong>验证需求</strong></p>
<p>为了确保已定义的需求（需求规格说明）准确无误，并能为客户（或用户）理解和接受，需要对其进行严格的评审。</p>
</li>
</ol>
<hr>
<h3 id="结构化分析方法"><a href="#结构化分析方法" class="headerlink" title="结构化分析方法"></a>结构化分析方法</h3><blockquote>
<p>传统的分析建模方法称为结构化分析（structured analysis，SA）方法。</p>
</blockquote>
<p>结构化分析方法是一种建模技术，它建立的分析模型如图所示。</p>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231229104334213.png" alt="image-20231229104334213" style="zoom: 70%;" />

<p>该模型的核心是数据字典，包括在目标系统中所使用和生成的所有数据对象。围绕这个核心有三种图</p>
<ol>
<li><strong>数据流图（DFD）</strong>：描述数据在系统中如何被传送或变换，以及描述如何对数据流进行变换的功能（子功能），用于功能建模。</li>
<li><strong>实体-关系图（ER图）</strong>：描述数据对象及数据对象之间的关系，用于数据建模。</li>
<li><strong>状态-迁移图（STD）</strong>：描述系统对外部事件如何响应、如何动作，用于行为建模。</li>
</ol>
<h4 id="功能建模"><a href="#功能建模" class="headerlink" title="功能建模"></a>功能建模</h4><blockquote>
<p> 功能建模的思想就是用抽象模型的概念，按照软件内部数据传递、变换的关系，自顶向下逐层分解，直到找到满足功能要求的所有可实现的软件为止。功能模型用数据流图来描述。</p>
</blockquote>
<ol>
<li><p>数据流图的基本图形符号</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20230912161513724.png" alt="image-20230912161513724"></p>
<p>多个数据流之间的关系</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20230912161752810.png" alt="image-20230912161752810"></p>
</li>
<li><p>环境图</p>
<blockquote>
<p>环境图（context diagram）也称为顶层数据流图（或0层数据流图)，它仅包括一个数据处理过程，也就是要开发的目标系统。环境图的作用是确定系统在其环境中的位置，通过确定系统的输人和输出与外部实体的关系确定其边界。</p>
</blockquote>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20230912161909164.png" alt="image-20230912161909164"></p>
</li>
<li><p>数据流图的分层</p>
<blockquote>
<p>稍为复杂一些的实际问题，在数据流图上常常出现十几个甚至几十个加工。这样的数据 ，流图看起来不直观，不易理解。分层的数据流图能很好地解决这一向题。按照系统的层次结结构进行逐步分解，并以分层的数据流图反映这种结构关系，能清楚地表达整个系统，也容易 理解。</p>
</blockquote>
</li>
</ol>
<h4 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h4><ul>
<li>在结构化分析方法中，使用实体—关系建模技术来建立数据模型。</li>
<li>这种技术是在较高的抽象层次（概念层）上对数据库结构进行建模的流行技术。</li>
<li>实体—关系模型表示为可视化的实体—关系图（entity-relationship diagram，ERD），也称为ER图。 </li>
<li>ER图中仅包含3种相互关联的元素：<strong>数据对象（实体）</strong>、描述数据对象的<strong>属性</strong>及数据对象彼此间相互连接的<strong>关系</strong>。</li>
</ul>
<h5 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h5><ul>
<li><p>数据对象是目标系统所需要的复合信息的表示，所谓复合信息是具有若干不同属性的信息。在<strong>ER</strong>图中用矩形表示数据对象。</p>
</li>
<li><p>在实际问题中，数据对象（实体）可以是外部实体、事物、角色、行为或事件、组织单位、地点或结构等。</p>
</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p>属性定义数据对象的特征，如数据对象学生的学号、姓名、性别、专业等，课程的课程编号、课程名称、学分等。</p>
</li>
<li><p>在<strong>ER</strong>图中用椭圆或圆角矩形表示属性，并用无向边将属性与相关的数据对象连接在一起</p>
</li>
</ul>
<h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><ul>
<li><p>不同数据对象的实例之间是有关联关系的，在<strong>ER</strong>图上用<strong>无向边</strong>表示。</p>
</li>
<li><p>在无向边的两端应标识出关联实例的数量，也称为关联的<strong>重数</strong>。</p>
</li>
<li><p>从关联重数的角度可以将关联分为３种。</p>
</li>
</ul>
<p><strong>(1)</strong> 一对一（<strong>1:1</strong>）关联</p>
<p><strong>(2)</strong> 一对多（<strong>1:m</strong>）关联</p>
<p><strong>(3)</strong> 多对多（<strong>m:n</strong>）关联</p>
<ul>
<li>实例关联还有“必须”和“可选”之分。</li>
</ul>
<p>​	在ER图中用圆圈表示所关联的实例是可选的，隐含表示“0”，没有出现圆圈就意味着是必须的。出现在连线上的短竖线可以看成是“1”。 </p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231229140200301.png" alt="image-20231229140200301"></p>
<h4 id="行为建模"><a href="#行为建模" class="headerlink" title="行为建模"></a>行为建模</h4><blockquote>
<p>状态转换图（简称状态图）通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。状态图中使用的主要符号如图所示。</p>
</blockquote>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="C:\Users\胡华裕\AppData\Roaming\Typora\typora-user-images\image-20231229140308010.png" alt="image-20231229140308010"></p>
<p><strong>状态的表示：</strong>初态用<strong>实心圆</strong>表示，终态用<strong>牛眼图</strong>形表示，中间态用<strong>圆角矩形</strong>表示。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231229140546665.png" alt="image-20231229140546665"></p>
<p>决策表</p>
<p>决策树</p>
<h2 id="结构化设计方法"><a href="#结构化设计方法" class="headerlink" title="结构化设计方法"></a>结构化设计方法</h2><h3 id="软件设计的概念与原则"><a href="#软件设计的概念与原则" class="headerlink" title="软件设计的概念与原则"></a>软件设计的概念与原则</h3><h4 id="软件设计的原则"><a href="#软件设计的原则" class="headerlink" title="软件设计的原则"></a>软件设计的原则</h4><h5 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h5><h5 id="模块独立性"><a href="#模块独立性" class="headerlink" title="模块独立性"></a>模块独立性</h5><p><strong>模块独立性的度量准则</strong></p>
<ul>
<li>**耦合:**是模块之间的互相连接的紧密程度的度量。</li>
<li>**内聚:**是模块功能强度(一个模块内部各个元素彼此结合的紧密程度)的度量。</li>
<li>模块独立性比较强的模块应是高内聚低耦合的模块。</li>
</ul>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231229143221598.png" alt="image-20231229143221598" style="zoom:50%;" />

<p><strong>非直接耦合（Nondirect Coupling）</strong></p>
<ul>
<li>两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。</li>
<li>非直接耦合的模块独立性最强。</li>
</ul>
<p><strong>数据耦合（Data Coupling）</strong></p>
<p>​	一个模块访问另一个模型时，彼此之间是通过简单数据参数（不是控制参数、公共数据结构或外部变量）来交换输入、输出信息的。也是比较理想的耦合。</p>
<p><strong>特征耦合（Stamp Coupling）</strong></p>
<p>一组模块通过参数表传递记录信息，就是特征耦合。这个记录是某一数据结构的子结构，而不是简单变量。</p>
<p><strong>控制耦合（Control Coupling）</strong></p>
<p>如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。</p>
<p><strong>公共耦合（Common Coupling）</strong></p>
<p>若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。</p>
<p><strong>内容耦合（Content Coupling）</strong></p>
<ul>
<li>一个模块直接访问另一个模块的内部数据</li>
<li>一个模块不通过正常入口转到另一模块内部。</li>
<li>两个模块有一部分程序代码重迭。(只可能出现在汇编语言中)。</li>
<li>一个模块有多个入口。</li>
</ul>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230090303481.png" alt="image-20231230090303481"></p>
<p><strong>偶然内聚（Coincidental COhesion）</strong></p>
<p>当模块内各部分之间没有联系，或者即使有联系，这种联系也很松散，则称这种模块为偶然内聚模块，内聚程度最低。</p>
<p><strong>逻辑内聚（Logical Cohesion）</strong></p>
<p>把几种相关的功能组合在一起，每次被调用时，由传送给模块的判定参数来确定该模块应执行哪个功能。</p>
<p><strong>时间内聚（Classical Cohesion）</strong></p>
<p>时间内聚模块大多为多功能模块，但模块的各个功能的执行与时间有关，通常要求所有功能必须在同一时间段内执行。</p>
<p><strong>过程内聚（Procedural Cohesion）</strong></p>
<p>如果一个模块内的处理是相关的，而且必须以特定次序执行，则是过程内聚。</p>
<p><strong>顺序内聚</strong></p>
<p>一个模块中的处理元素和同一功能密切相关，而且这些处理必须顺序执行，则称为顺序内聚。</p>
<p><strong>功能内聚 (Functional Cohesion)</strong></p>
<p>一个模块中各个部分都是完成某一具体功能必不可少的组成部分，或者说该模块中所有部分都是为了完成一项具体功能而协同工作，紧密联系，不可分割的。则称该模块为功能内聚模块。</p>
<h5 id="提高抽象层次"><a href="#提高抽象层次" class="headerlink" title="提高抽象层次"></a>提高抽象层次</h5><ul>
<li>抽象是指忽视一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。</li>
<li>当我们进行软件设计时，设计开始时应尽量提高软件的抽象层次，按抽象级别从高到低进行软件设计。</li>
</ul>
<h5 id="复用性设计"><a href="#复用性设计" class="headerlink" title="复用性设计"></a>复用性设计</h5><ul>
<li>复用是指同一事物不做修改或稍加修改就可以多次重复使用。将复用的思想用于软件开发，称为软件复用。</li>
<li>我们将软件的重用部分称为软构件。</li>
<li>也就是说，在构造新的软件系统时不必从零做起，可以直接使用已有的软构件即可组装（或加以合理修改）成新的系统。</li>
</ul>
<h5 id="灵活性设计"><a href="#灵活性设计" class="headerlink" title="灵活性设计"></a>灵活性设计</h5><h3 id="结构化设计"><a href="#结构化设计" class="headerlink" title="结构化设计"></a>结构化设计</h3><h4 id="软件设计的任务"><a href="#软件设计的任务" class="headerlink" title="软件设计的任务"></a>软件设计的任务</h4><ul>
<li>从工程管理的角度，可以将软件设计分为<strong>概要设计阶段</strong>和<strong>详细设计阶段</strong>。</li>
<li>从技术的角度，传统的结构化方法将软件设计划分为体系结构设计、数据设计、接口设计和过程设计4部分；</li>
<li>面向对象方法则将软件设计划分为体系结构设计、类设计&#x2F;数据设计、接口设计和构件级设计4部分。</li>
</ul>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230091024955.png" alt="image-20231230091024955"></p>
<ul>
<li><p><strong>体系结构设计：</strong>体系结构设计定义软件的主要结构元素及其之间的关系。</p>
</li>
<li><p><strong>接口设计</strong>：接口设计描述用户界面，软件和其他硬件设备、其他软件系统及使用人员的外部接口，以及各种构件之间的内部接口。</p>
</li>
<li><p><strong>数据设计：</strong>传统方法主要根据需求阶段所建立的实体—关系图（ER图）来确定软件涉及的文件系统的结构及数据库的表结构。 </p>
</li>
<li><p><strong>过程设计：</strong>过程设计的主要工作是确定软件各个组成部分内的算法及内部数据结构，并选定某种过程的表达形式来描述各种算法。</p>
</li>
</ul>
<h3 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h3><h4 id="基于数据流方法的设计过程"><a href="#基于数据流方法的设计过程" class="headerlink" title="基于数据流方法的设计过程"></a>基于数据流方法的设计过程</h4><p>…</p>
<h3 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h3><h4 id="标志符号"><a href="#标志符号" class="headerlink" title="标志符号"></a>标志符号</h4><p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102154451072.png" alt="image-20240102154451072"></p>
<h4 id="McCabe度量法"><a href="#McCabe度量法" class="headerlink" title="McCabe度量法"></a>McCabe度量法</h4><p>环路复杂度：</p>
<p>V（G）&#x3D; E - N + 2</p>
<p>E：边数</p>
<p>N：顶点数</p>
<h2 id="面向对象方法与UML"><a href="#面向对象方法与UML" class="headerlink" title="面向对象方法与UML"></a>面向对象方法与UML</h2><blockquote>
<p>面向对象＝对象＋类＋继承＋消息通信</p>
</blockquote>
<h3 id="UML简介"><a href="#UML简介" class="headerlink" title="UML简介"></a>UML简介</h3><p><strong>面向对象的建模语言</strong>很多，目前使用最广泛的是统一建模语言(UML，Unified Modeling Language)；</p>
<p><strong>特点：</strong></p>
<ol>
<li><p><strong>统一标准</strong></p>
<p>UML不仅统一了Booch、OMT和OOSE等方法中的基本概念，还吸取了面向对象技术领域中其他流派的长处，其中也包括非OO方法的影响。已经成为OMG的标准。  </p>
</li>
<li><p><strong>面向对象</strong></p>
<p>   UML支持面向对象技术的主要概念，它提供了一批基本的表示模型元素的图形和方法，能简洁明了地表达面向对象的各种概念和模型元素。</p>
</li>
<li><p><strong>可视化，表达能力强</strong></p>
<p>UML是一种图形化语言，用UML的模型图形能清晰地表示系统的逻辑模型或实现模型。UML还提供了语言的扩展机制，用户可以根据需要增加定义自己的构造型、标记值和约束等。 </p>
</li>
<li><p><strong>独立于过程</strong></p>
<p>UML是系统建模的语言，不依赖特定的开发过程。</p>
</li>
<li><p><strong>易于掌握使用</strong></p>
<p>UML概念明确，建模表示法简洁明了，图形结构清晰，容易掌握使用。</p>
</li>
</ol>
<h3 id="UML基本模型"><a href="#UML基本模型" class="headerlink" title="UML基本模型"></a>UML基本模型</h3><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230100856738.png" alt="image-20231230100856738" style="zoom:80%;" />

<h3 id="UML的事物"><a href="#UML的事物" class="headerlink" title="UML的事物"></a>UML的事物</h3><ul>
<li>事物是对模型中最具代表性成分的抽象，在UML中，可以分为<strong>结构事物、行为事物、分组事物</strong>和<strong>注释事物</strong>4类。</li>
</ul>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230104253226.png" alt="image-20231230104253226"></p>
<h4 id="结构事物"><a href="#结构事物" class="headerlink" title="结构事物"></a>结构事物</h4><ul>
<li>结构事物是UML模型的<strong>静态部分</strong>，主要用来描述概念的或物理的元素，包括类、主动类、接口、对象、用例、参与者、协作、构件和节点等。</li>
</ul>
<ol>
<li><p>类（class）── 类用带有类名、属性和操作的矩形框来表示。</p>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101422858.png" alt="image-20231230101422858" style="zoom: 50%;" />

<p><strong>可见性：</strong></p>
<p>+: public</p>
<p>-: private</p>
<p>#: protected</p>
<p>~: package&#x2F;default</p>
</li>
<li><p>主动类（active class）── 主动类的实例应具有一个或多个进程或线程，能够启动控制活动。</p>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101541517.png" alt="image-20231230101541517" style="zoom:50%;" />
</li>
<li><p>接口（interface）── 描述了一个类或构件的一组外部可用的服务（操作）集。</p>
<p>接口定义的是一组操作的描述，而不是操作的实现。一般将接口画成从实现它的类或构件引出的圆圈，接口体现了使用与实现分离的原则。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101707479.png" alt="image-20231230101707479"></p>
</li>
<li><p>对象（object）── 对象是类的实例，其名字下边加下划线，对象的属性值需明确给出。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101853215.png" alt="image-20231230101853215"></p>
</li>
<li><p>用例（use case）── 也称用况，用于表示系统想要实现的<strong>行为</strong>，即描述<strong>一组动作序列</strong>（即场景）。而系统执行这组动作后将产生一个对特定参与者有价值的结果。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101921330.png" alt="image-20231230101921330"></p>
</li>
<li><p>参与者（actor）── 也称角色，是指与系统有信息交互关系的人、软件系统或硬件设备，在图形上用简化的小木头人表示。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230101948468.png" alt="image-20231230101948468"></p>
</li>
<li><p>协作（collaboration）── 用例仅描述要实现的行为，不描述这些行为的实现。这种实现用协作描述。</p>
<p>协作定义交互，描述一组角色实体和其他实体如何通过协同工作来完成一个功能或行为。类可以参与几个协作。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102052151.png" alt="image-20231230102052151"></p>
</li>
<li><p>构件（component）── 也称组件，是系统中物理的、可替代的部件。它通常是描述一些逻辑元素的物理包。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102139964.png" alt="image-20231230102139964"></p>
</li>
<li><p>节点（node）── 是在运行时存在的物理元素。它代表一种可计算的资源，通常具有一定的记忆能力和处理能力。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102149994.png" alt="image-20231230102149994"></p>
</li>
</ol>
<h4 id="行为事物"><a href="#行为事物" class="headerlink" title="行为事物"></a>行为事物</h4><ul>
<li>行为事物是UML模型的动态部分，包括两类：</li>
</ul>
<ol>
<li><p><strong>交互（interaction）</strong>── 交互由在特定的上下文环境中共同完成一定任务的一组对象之间传递的消息组成。如图所示。交互涉及的元素包括消息、动作序列（由一个消息所引起的行为）和链（对象间的连接）。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102315130.png" alt="image-20231230102315130"></p>
</li>
<li><p><strong>状态机（state machine）</strong>── 描述了一个对象或一个交互在生存周期内响应事件所经历的状态序列，单个类或者一组类之间协作的行为都可以用状态机来描述。</p>
<p>状态机涉及到状态、变迁和活动，其中状态用圆角矩形来表示。</p>
<p> <img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102349995.png" alt="image-20231230102349995"></p>
</li>
</ol>
<h4 id="分组事物"><a href="#分组事物" class="headerlink" title="分组事物"></a>分组事物</h4><ul>
<li>分组事物是UML模型的组织部分。它的作用是为了降低模型复杂性。</li>
<li>UML中的分组事物是包（package）。</li>
<li>包是把模型元素组织成组的机制，结构事物、行为事物甚至其他分组事物都可以放进包内。</li>
</ul>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102455330.png" alt="image-20231230102455330"></p>
<h4 id="注释事物"><a href="#注释事物" class="headerlink" title="注释事物"></a>注释事物</h4><ul>
<li>注释事物是UML模型的解释部分，它们用来描述和标注模型的任何元素。</li>
<li>通常可以用注释修饰带有约束或者解释的图。</li>
</ul>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102525238.png" alt="image-20231230102525238"></p>
<h3 id="UML的关系"><a href="#UML的关系" class="headerlink" title="UML的关系"></a>UML的关系</h3><p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102748541.png" alt="image-20231230102748541"></p>
<h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><ul>
<li>依赖(Dependency)是两个事物之间的语义关系，其中一个事物发生变化会影响到另一个事物的语义，它用一个虚线箭头表示。</li>
<li>虚线箭头的方向从源事物指向目标事物，表示源事物依赖于目标事物。</li>
</ul>
<p> 	</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230105352997.png" alt="image-20231230105352997"></p>
<h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><ul>
<li><p>关联(association)是一种结构关系，它描述了两个或多个类的实例之间的连接关系，是一种特殊的依赖。 </p>
</li>
<li><p>关联分为<strong>普通关联</strong>、<strong>限定关联</strong>、关联类，以及<strong>聚合</strong>与<strong>复合</strong>。</p>
</li>
<li><p><strong>多重性（multiplicity）</strong>：多重性表明在一个关联的两端连接的类实例个数的对应关系，即一端的类的多少个实例对象可以与另一端的类的一个实例相关。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101102140470.png" alt="image-20240101102140470"></p>
</li>
</ul>
<h5 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h5><ul>
<li>聚合（Aggregation）也称为聚集，是一种特殊的关联。它描述了整体和部分之间的结构关系。</li>
<li>两种特殊的聚合关系：共享聚合（shared aggregation）和复合聚合（composition aggregation）。</li>
<li>如果在聚合关系中处于部分方的实例可同时参与多个处于整体方实例的构成，则该聚合称为共享聚合。</li>
<li>如果部分类完全隶属于整体类，部分类需要与整体类共存，一旦整体类不存在了，则部分类也会随之消失，或失去存在价值，则这种聚合称为复合聚合。</li>
</ul>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101102414333.png" alt="image-20240101102414333"></p>
<h4 id="泛化关系（继承）"><a href="#泛化关系（继承）" class="headerlink" title="泛化关系（继承）"></a>泛化关系（继承）</h4><p>泛化(generalization)关系就是一般类和特殊类之间的继承关系。在UML中，一般类亦称泛化类，特殊类亦称特化类。</p>
<h4 id="实现关系（实现）"><a href="#实现关系（实现）" class="headerlink" title="实现关系（实现）"></a>实现关系（实现）</h4><p>**实现(implement)**是泛化关系和依赖关系的结合，也是类之间的语义关系，通常在以下两种情况出现实现关系：</p>
<ol>
<li>接口和实现它们的类或构件之间；</li>
<li>用例和实现它们的协作之间。</li>
</ol>
<h3 id="UML的图"><a href="#UML的图" class="headerlink" title="UML的图"></a>UML的图</h3><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230102828422.png" alt="image-20231230102828422" style="zoom:80%;" />

<h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><blockquote>
<p>用例模型描述的是外部执行者(actor)所理解的系统功能。用例模型用于需求分析阶段，它的建立是系统开发者和用户反复讨论的结果，描述了开发者和用户对需求规格达成的共识。</p>
</blockquote>
<p><strong>四个元素：</strong>1. <strong>系统</strong> 2. <strong>参与者</strong> 3.<strong>用例</strong> 4. <strong>关系</strong></p>
<ul>
<li>主要参与者放左边，次要参与者放右边</li>
<li>包含依赖一定执行，扩展依赖要满足一定条件执行</li>
</ul>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230123716222.png" alt="image-20231230123716222" style="zoom:70%;" />

<p><strong>关系类型</strong>：</p>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230115123877.png" alt="image-20231230115123877" style="zoom:0%;" />

<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qN41177fw/?spm_id_from=333.999.0.0&vd_source=c976b64c190c9a4e94816b10afd4086d">6 分钟学会 UML 用例图_哔哩哔哩_bilibili</a></p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><blockquote>
<p> 类图描述类和类与类之间的静态关系，它是从静态角度表示系统的，因此类图属于一种静态模型。类图是构建其他图的基础，没有类图就没有状态图、协作图等其他图，也就无法表示系统其他方面的特性。</p>
<p>类图显示了类（及其接口）、类的内部结构以及与其他类的联系。联系是指类元之间的联系，在类的建模中可以使用关联、聚合和泛化（继承）关系。</p>
</blockquote>
<p><strong>类</strong></p>
<p><strong>关系：</strong></p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20231230124956825.png" alt="image-20231230124956825"></p>
<p><strong>聚合（aggregation）关系：</strong>没有父类子类可以独立存在。</p>
<p><strong>组合（composition）关系：</strong>没有父类子类无法存在。</p>
<h4 id="交互图"><a href="#交互图" class="headerlink" title="交互图"></a>交互图</h4><h5 id="顺序图（时序图、序列图）"><a href="#顺序图（时序图、序列图）" class="headerlink" title="顺序图（时序图、序列图）"></a>顺序图（时序图、序列图）</h5><blockquote>
<p>顺序图描述对象之间的动态交互关系，着重表现对象间消息传递的时间顺序。</p>
</blockquote>
<p><strong>元素：</strong>角色（Actor）、对象（Object）、生命线（LifeLine）、控制焦点（Activation）、消息（Message）、自关联消息、组合片段</p>
<p><strong>角色(Actor)</strong><br>系统角色，可以是人或者其他系统，子系统。以一个小人图标表示。</p>
<p><strong>对象(Object)</strong><br>对象位于时序图的顶部,以一个矩形表示。对象的命名方式一般有三种：<br>    1 对象名和类名。例如：华为手机:手机、loginServiceObject:LoginService。<br>    2 只显示类名，不显示对象，即为一个匿名类。例如：:手机、:LoginSservice。<br>    3 只显示对象名，不显示类名。例如：华为手机:、loginServiceObject:。</p>
<p><strong>生命线(LifeLine)</strong><br>时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线(对象的时间线)。以一条垂直的虚线表。</p>
<p><strong>控制焦点(Activation)</strong><br>控制焦点代表时序图中在对象时间线上某段时期执行的操作。以一个很窄的矩形表示。</p>
<p><strong>消息(Message)</strong><br>表现代表对象之间发送的信息。消息分为三种类型。</p>
<p> <strong>同步消息(Synchronous Message)</strong><br>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。以一条实线+实心箭头表示。</p>
<p> <strong>异步消息(Asynchronous Message)</strong><br>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。以一条实线+大于号表示。</p>
<p><strong>返回消息(Return Message)</strong><br>返回消息表示从过程调用返回。以小于号+虚线表示。</p>
<p><strong>自关联消息</strong><br>表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。以一个半闭合的长方形+下方实心剪头表示。</p>
<p><strong>组合片段</strong><br>组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="https://img-blog.csdn.net/20180704144557365?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseV96eHk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h5 id="通信图（协作图）"><a href="#通信图（协作图）" class="headerlink" title="通信图（协作图）"></a>通信图（协作图）</h5><blockquote>
<p>通信图是顺序图的一种变化形式，用于描述相互协作的对象间的交互关系和链接关系。 </p>
</blockquote>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101114327644.png" alt="image-20240101114327644"></p>
<h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><blockquote>
<p>状态图描述一个特定对象的所有可能的状态以及引起状态转换的事件。大多数面向对象技术都用状态图表示单个对象在其生命期中的行为。一个状态图包括一系列状态、事件以及状态之间的转移。</p>
</blockquote>
<p><strong>组成：</strong>状态、转换、事件</p>
<ul>
<li><strong>状态</strong>：表示对象的生命周期的一种条件&#x2F;情况，有初态和终态之分</li>
</ul>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="https://pic1.zhimg.com/80/v2-5ebccf8799ff3b33b42ed2235ef1ad78_720w.webp" alt="img"></p>
<ul>
<li><p><strong>转换：</strong>两个状态之间的关系，它表明当某事发生时，对象先从当前状态转换到后来的状态，用<strong>带有标记事件的箭头</strong>表示。</p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="https://pic2.zhimg.com/80/v2-c5b438f27b80c043d9161b6d1dc41a1d_720w.webp" alt="img"></p>
</li>
<li><p><strong>事件：</strong>事件时引发变迁的消息，用箭头上的标记（事件表达式）表示。</p>
</li>
</ul>
<h4 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h4><blockquote>
<p>活动图用来捕捉用例的活动，使用框图的方式显示动作及其结果。</p>
<p>活动图是一个流图，描述了从活动到活动的流。</p>
<p>它是另一种描述交互的方式，它描述采取何种动作，动作的结果是什么(动作状态改变)，何时发生(动作序列)，以及在何处发生(泳道)。 </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149079804">11. 面向对象——UML活动图（Activity Diagram） - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zp4y1Z7nV/">3 分钟学会 UML 活动图_哔哩哔哩_bilibili</a></p>
<p>基本元素：1. 活动节点 2. 初始节点和终止节点 3. 转换 4.决策节点（空心菱型） 5.分叉与汇合(黑色粗线)</p>
<p><strong>泳道图：</strong>按角色进行分组，流程的信息表达更加清晰准确。</p>
<h4 id="构件图"><a href="#构件图" class="headerlink" title="构件图"></a>构件图</h4><blockquote>
<p>构件图描述软件构件及构件之间的依赖关系，显示代码的静态结构。</p>
<p>构件是逻辑架构中定义的概念和功能(例如，类、对象及它们之间的关系)在物理架构中的实现。典型情况下，构件是开发环境中的实现文件。</p>
</blockquote>
<p>软件构件分类：</p>
<ul>
<li><strong>源构件</strong>：源构件仅在编译时才有意义。典型情况下，它是实现一个或多个类的源代码文件。</li>
<li><strong>二进制构件</strong>：典型情况下，二进制构件是对象代码，它是源构件的编译结果。</li>
<li><strong>可执行构件</strong>：可执行构件是一个可执行的程序文件，它是链接所有二进制构件所得到的结果。一个可执行构件代表在处理器(计算机)上运行的可执行单元。</li>
</ul>
<h4 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h4><blockquote>
<p>部署图描述处理器、设备和连接，它显示系统硬件的物理拓扑结构及在此结构上执行的软件。<br>部署图可以显示计算节点的拓扑结构和通信路径、节点上运行的软件以及软件包含的逻辑单元。 </p>
</blockquote>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101123138498.png" alt="image-20240101123138498" style="zoom:50%;" />



<h2 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h2><h3 id="面向对象分析概述"><a href="#面向对象分析概述" class="headerlink" title="面向对象分析概述"></a>面向对象分析概述</h3><h4 id="确定系统边界"><a href="#确定系统边界" class="headerlink" title="确定系统边界"></a>确定系统边界</h4><p>系统边界是系统的所有内部成分与系统以外各种事物的分界线。系统只通过边界上有限数量的接口与外部的系统参与者（人员、组织、设备或外系统）进行交互。</p>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101123643096.png" alt="image-20240101123643096" style="zoom:50%;" />

<h4 id="面向对象分析的3种模型"><a href="#面向对象分析的3种模型" class="headerlink" title="面向对象分析的3种模型"></a>面向对象分析的3种模型</h4><ul>
<li><strong>用例模型</strong>：用例和场景表示的功能模型；</li>
<li><strong>对象模型</strong>：用类和对象表示的静态模型；</li>
<li><strong>交互模型</strong>：由状态图和顺序图表示的动态模型。</li>
</ul>
<h3 id="建立用例模型"><a href="#建立用例模型" class="headerlink" title="建立用例模型"></a>建立用例模型</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li><strong>确定业务参与者</strong>──标识目标系统将支持的不同类型的用户，可以是人、事件或其他系统。</li>
<li><strong>确定业务需求用例</strong>──参与者需要系统提供的完整功能。</li>
<li><strong>创建用例图</strong>──标识参与者与用例之间、用例与用例之间的关系。</li>
</ol>
<h3 id="建立对象模型"><a href="#建立对象模型" class="headerlink" title="建立对象模型"></a>建立对象模型</h3><h4 id="对象模型的5个层次"><a href="#对象模型的5个层次" class="headerlink" title="对象模型的5个层次"></a>对象模型的5个层次</h4><blockquote>
<p>Coad &amp; Yourdon提出，复杂问题(大型系统)的对象模型应该由下述5个层次组成：</p>
<p>主题层(也称为范畴层)、类-对象层、结构层、属性层和服务层，如图所示。 </p>
</blockquote>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240101124901532.png" alt="image-20240101124901532" style="zoom:80%;" />

<h3 id="建立动态模型"><a href="#建立动态模型" class="headerlink" title="建立动态模型"></a>建立动态模型</h3><blockquote>
<p>在开发交互式系统时，动态模型起着很重要的作用。<br>在UML中动态模型的描述工具有顺序图、通信图和状态图。</p>
</blockquote>
<h2 id="软件体系结构与设计模式"><a href="#软件体系结构与设计模式" class="headerlink" title="软件体系结构与设计模式"></a>软件体系结构与设计模式</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><a target="_blank" rel="noopener" href="https://makeoptim.com/training/typescript-design-patterns">软件修养 – 一篇搞定设计原则和 23 种设计模式 | MakeOptim</a></p>
<h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><h5 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h5><p>定义一个<strong>创建对象的接口</strong>，但让<strong>实现这个接口的类</strong>来决定<strong>实例化哪个类</strong>。工厂方法让类的实例化<strong>推迟到子类中进行</strong>。</p>
<h5 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h5><p>为一个<strong>产品族</strong>提供了<strong>统一的创建接口</strong>。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类，而<strong>无需指定它们的具体类</strong>。</p>
<h4 id="构造型"><a href="#构造型" class="headerlink" title="构造型"></a>构造型</h4><h5 id="适配器模式（Adapter、Wrapper、Translator）"><a href="#适配器模式（Adapter、Wrapper、Translator）" class="headerlink" title="适配器模式（Adapter、Wrapper、Translator）"></a>适配器模式（Adapter、Wrapper、Translator）</h5><p>将某个类的接口<strong>转换成客户端期望的</strong>另一个<strong>接口表示</strong>。适配器模式可以<strong>消除由于接口不匹配</strong>所造成的<strong>类兼容性问题</strong>。</p>
<h4 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h4><h5 id="观察者模式（Observer-or-Publish-subscribe）"><a href="#观察者模式（Observer-or-Publish-subscribe）" class="headerlink" title="观察者模式（Observer or Publish&#x2F;subscribe）"></a>观察者模式（Observer or Publish&#x2F;subscribe）</h5><p>在对象间定义一个<strong>一对多</strong>的联系性，由此<strong>当一个对象改变</strong>了状态，所有其他<strong>相关的对象</strong>会被<strong>通知</strong>并且<strong>自动刷新</strong>。</p>
<h6 id="黑板模式-Blackboard-Design-Pattern"><a href="#黑板模式-Blackboard-Design-Pattern" class="headerlink" title="黑板模式(Blackboard Design Pattern)"></a>黑板模式(Blackboard Design Pattern)</h6><p>黑板模式（Blackboard Design Pattern）是<strong>观察者模式的一个扩展</strong>：<strong>允许消息的读写同时进行</strong>，广泛地交互消息。</p>
<h5 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h5><p>定义一个<strong>算法的系列</strong>，将其各个<strong>分装</strong>，并且使他们<strong>有交互性</strong>。策略模式使得<strong>算法</strong>在用户使用的时候能<strong>独立的改变</strong>。</p>
<h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><h3 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h3><p><a target="_blank" rel="noopener" href="https://makeoptim.com/tags#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">Tags | MakeOptim</a></p>
<h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>单一职责原则（SRP：Single responsibility principle）：一个类应该<strong>只有一个发生变化的原因</strong>，即一个类<strong>只负责一项职责</strong>。</p>
<h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>开闭原则（OCP ：Open Closed Principle）：软件中的<strong>实体（类，模块，函数等等）</strong>应该<strong>对扩展开放，对修改封闭</strong>，这意味着一个实体是允许在<strong>不改变它的源代码的前提下变更它的行为</strong>。</p>
<h4 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h4><p>里氏替换原则（LSP：Liskov Substitution Principle）：<strong>派生类（子类）对象可以在程序中代替其基类（超类）对象</strong>。</p>
<h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p>依赖倒置原则（DIP ：Dependence Inversion Principle）：</p>
<ul>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li>抽象不应该依赖细节</li>
<li>细节应该依赖抽象</li>
</ul>
<p><strong>也就是说高层模块，低层模块，细节都应该依赖抽象</strong></p>
<h4 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h4><p>迪米特法则（LOD：Law Of Demeter）：又叫作<strong>最少知识原则</strong>（Least Knowledge Principle，LKP)。只与你的<strong>直接的</strong>朋友交谈，<strong>不跟“陌生人”说话</strong>（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体<strong>无须直接通信</strong>，那么就<strong>不应当发生直接的相互调用</strong>，可以通过第三方<strong>转发</strong>该调用。其目的是<strong>降低类之间的耦合度</strong>，提高模块的相对<strong>独立性</strong>。</p>
<h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p>接口隔离原则（ISP ：Interface Segregation Principle）：客户端<strong>不应该依赖它不需要的接口</strong>。一个类对另一个类的依赖应该建立在<strong>最小的接口</strong>上。</p>
<h4 id="组合-聚合原则"><a href="#组合-聚合原则" class="headerlink" title="组合&#x2F;聚合原则"></a>组合&#x2F;聚合原则</h4><p>组合&#x2F;聚合复用原则（CARP：Composite&#x2F;Aggregate Reuse Principle）：在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新对象通过向这些对象的委派达到复用已有功能的目的。就是说要尽量的使用合成和聚合，而<strong>不是继承关系达到复用的目的</strong>。</p>
<p>简短表达就是：<strong>尽量使用组合&#x2F;聚合，尽量不要使用继承</strong>。</p>
<h2 id="软件测试方法"><a href="#软件测试方法" class="headerlink" title="软件测试方法"></a>软件测试方法</h2><h3 id="软件测试的基本概念"><a href="#软件测试的基本概念" class="headerlink" title="软件测试的基本概念"></a>软件测试的基本概念</h3><p><strong>什么是软件测试？</strong></p>
<ul>
<li>软件测试是在软件投入生产性运行之前，对软件需求分析、设计规格说明和编码的最终复审，是软件质量控制的关键步骤。</li>
<li>软件测试是为了发现错误而执行程序的过程。</li>
<li>或者说，软件测试是根据软件开发各阶段的规格说明和程序的内部结构而精心设计一批测试用例（即输入数据及其预期的输出结果），并利用这些测试用例去运行程序，以发现程序错误的过程。</li>
</ul>
<p><strong>软件测试的目的</strong></p>
<p>​	基于不同的立场，存在着两种完全不同的测试目的。</p>
<ul>
<li>从用户的角度出发，普遍希望通过软件测试检验软件中隐藏的错误和缺陷，以考虑是否可以接受该产品。</li>
<li>从软件开发者的角度出发，则希望测试成为表明软件产品中不存在错误的过程，验证该软件已正确地实现了用户的要求，确立人们对软件质量的信心。</li>
</ul>
<p><strong>测试方法与技术</strong></p>
<ul>
<li><p>机器测试</p>
<p>在设定的测试数据上执行被测程序的过程。又称动态测试。</p>
</li>
<li><p>人工测试</p>
<p>采用人工方法进行，目的在于检查程序的静态结构，找出编译不能发现的错误。</p>
</li>
</ul>
<p><strong>人工测试分类</strong></p>
<ul>
<li>代码审查<br>以小组会的形式，发现程序在结构、功能、编码风格等方面存在的问题。可查出30%~70%的错误</li>
<li>走查<br>以小组会的形式进行，把测试数据“输入”到被测程序，并在纸上跟踪监视程序的执行情况，让人代替机器沿着程序的逻辑走一遍。</li>
<li>桌前检查<br>设计模块时，程序员自己检查。</li>
</ul>
<p><strong>机器测试分类</strong></p>
<ul>
<li>黑盒测试</li>
</ul>
<blockquote>
<p>黑盒测试是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。</p>
</blockquote>
<ul>
<li>白盒测试</li>
</ul>
<blockquote>
<p>白盒测试是对软件的过程性细节做细致的检查。<br>这一方法是把测试对象看做一个打开的盒子或透明的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。<br>通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。<br>因此，白盒测试又称为结构测试或逻辑驱动测试。</p>
</blockquote>
<h3 id="白盒测试的测试用例设计"><a href="#白盒测试的测试用例设计" class="headerlink" title="白盒测试的测试用例设计"></a>白盒测试的测试用例设计</h3><h4 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h4><blockquote>
<p>逻辑覆盖是以程序内部的逻辑结构为基础的设计测试用例</p>
<p>的技术，它属于白盒测试。</p>
</blockquote>
<p>由于覆盖测试的目标不同，逻辑覆盖又可分为： </p>
<ul>
<li>语句覆盖</li>
<li>判定覆盖</li>
<li>判定—条件覆盖</li>
<li>条件组合覆盖</li>
<li>路径覆盖</li>
</ul>
<h4 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a>语句覆盖</h4><blockquote>
<p>语句覆盖就是设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次。</p>
</blockquote>
<h4 id="判定覆盖"><a href="#判定覆盖" class="headerlink" title="判定覆盖"></a>判定覆盖</h4><blockquote>
<p>判定覆盖就是设计若干个测试用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次。判定覆盖又称为分支覆盖。</p>
</blockquote>
<h4 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h4><blockquote>
<p>条件覆盖就是设计若干个测试用例，运行被测程序，使得程序中每个判断的每个条件的可能取值至少执行一次。</p>
<p>每个条件真假走一次</p>
</blockquote>
<h4 id="判定-条件覆盖"><a href="#判定-条件覆盖" class="headerlink" title="判定-条件覆盖"></a>判定-条件覆盖</h4><blockquote>
<p>所谓判定-条件覆盖就是设计足够的测试用例，使得判断中<br>每个条件的所有可能取值至少执行一次，同时每个判断本身<br>的所有可能判断结果至少执行一次。</p>
</blockquote>
<h4 id="条件组合覆盖"><a href="#条件组合覆盖" class="headerlink" title="条件组合覆盖"></a>条件组合覆盖</h4><blockquote>
<p>条件组合覆盖就是设计足够的测试用例，运行被测程序，使得每个判断的所有可能的条件取值组合至少执行一次。</p>
</blockquote>
<h4 id="路径测试"><a href="#路径测试" class="headerlink" title="路径测试"></a>路径测试</h4><blockquote>
<p>路径测试是设计足够的测试用例，覆盖程序中所有可能的路径。</p>
</blockquote>
<h3 id="基本路径覆盖"><a href="#基本路径覆盖" class="headerlink" title="基本路径覆盖"></a>基本路径覆盖</h3><p>基本路径测试是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。</p>
<h3 id="黑盒测试的测试用例设计"><a href="#黑盒测试的测试用例设计" class="headerlink" title="黑盒测试的测试用例设计"></a>黑盒测试的测试用例设计</h3><h4 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h4><ul>
<li>等价类划分是一种典型的黑盒测试方法，也是一种非常实用的重要测试方法,它是用来解决如何选择适当的子集，使其尽可能多地发现错误。</li>
<li>使用这一方法设计测试用例要经历<strong>划分等价类</strong>（列出等价类表）和<strong>选取测试用例</strong>两步。</li>
</ul>
<h5 id="划分等价类"><a href="#划分等价类" class="headerlink" title="划分等价类"></a>划分等价类</h5><p>所谓等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，并合理地假定：测试某等价类的代表值等价于对这一类其他值的测试。</p>
<p><strong>等价类的划分</strong>：</p>
<ol>
<li><p><strong>有效等价类</strong></p>
<p>有效等价类：是指对于程序的规格说明来说，是合理的、有意义的输入数据构成的集合。利用它，可以检验程序是否实现了规格说明预先规定的功能和性能。</p>
</li>
<li><p><strong>无效等价类</strong></p>
<p>是指对于程序的规格说明来说，是不合理的、无意义的输入数据构成的集合。程序员主要利用这一类测试用例检查程序中功能和性能的实现是否有不符合规格说明要求的地方。</p>
</li>
</ol>
<p>​	在设计测试用例时，要同时考虑有效等价类和无效等价类的设计。</p>
<h5 id="确定测试用例"><a href="#确定测试用例" class="headerlink" title="确定测试用例"></a>确定测试用例</h5><p>在确定了等价类之后，建立等价类表，列出所有划分出的等价类，如下： </p>
<p><img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102162856504.png" alt="image-20240102162856504"></p>
<p>再从划分出的等价类中按以下原则选择测试用例。<br>（1）为每一个等价类规定一个唯一的编号。<br>（2）设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止。<br>（3）设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。</p>
<h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4><ul>
<li>边界值分析也是一种黑盒测试方法，是对等价类划分方法的补充。人们从长期的测试工作经验中得知，大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部。</li>
<li>这里所说的边界是指，相当于输入等价类和输出等价类而言，稍高于其边界值及稍低于其边界值的一些特定情况。</li>
</ul>
<h3 id="软件测试策略"><a href="#软件测试策略" class="headerlink" title="软件测试策略"></a>软件测试策略</h3><p>通常<strong>软件测试过程</strong>按4个步骤进行，即<mark>单元测试</mark>、<mark>组装测试(集成测试)</mark>、<mark>确认测试</mark>和<mark>系统测试</mark>。如下图所示。</p>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102161943964.png" alt="image-20240102161943964" style="zoom: 60%;" />

<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><blockquote>
<p>单元测试（unit testing）又称模块测试，是针对软件设计的最小单位—程序模块，进行正确性检验的测试工作。其目的在于发现各模块内部可能存在的各种差错。单元测试需要从程序的内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。</p>
</blockquote>
<h5 id="单元测试内容"><a href="#单元测试内容" class="headerlink" title="单元测试内容"></a>单元测试内容</h5><blockquote>
<p>单元测试主要采用白盒测试方法设计测试用例，辅之以黑盒测试的测试用例，使之对任何合理的输入和不合理的输入，都能鉴别和响应。在单元测试中进行的测试工作如下图所示，需要在5个方面对被测模块进行检查。 </p>
</blockquote>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102164134720.png" alt="image-20240102164134720" style="zoom: 80%;" />

<ol>
<li>模块接口测试</li>
<li>局部数据结构测试</li>
<li>路径测试</li>
<li>错误处理测试</li>
<li>边界测试</li>
</ol>
<h5 id="单元测试步骤"><a href="#单元测试步骤" class="headerlink" title="单元测试步骤"></a>单元测试步骤</h5><ol>
<li>驱动模块</li>
<li>桩模块</li>
</ol>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102185005911.png" alt="image-20240102185005911" style="zoom:50%;" />

<h4 id="组装测试"><a href="#组装测试" class="headerlink" title="组装测试"></a>组装测试</h4><blockquote>
<p>组装测试（integrated testing）也叫做集成测试或联合测试。通常，在单元测试的基础上，需要将所有模块按照设计要求组装成为系统，把模块组装为系统的方式有两种：一次性组装方式（big bang）和增值式组装方式。</p>
</blockquote>
<h4 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h4><blockquote>
<p>确认测试（validation testing）又称有效性测试。它的任务是验证软件的有效性，即验证软件的功能和性能及其他特性是否与用户的要求一致。在确认测试阶段需要做的工作如下图所示。</p>
</blockquote>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240102185138824.png" alt="image-20240102185138824" style="zoom:80%;" />

<ol>
<li><p>进行有效性测试（黑盒测试）</p>
</li>
<li><p>软件配置复查</p>
</li>
<li><p>α测试和β测试</p>
<p>α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试。软件在一个自然设置状态下使用，开发者坐在用户旁边，随时记下错误情况和使用中的问题。 α测试的目的是评价软件产品的FLURPS（即功能、局域化、可使用性、可靠性、性能和支持），尤其注重产品的界面和特色。</p>
<p>β测试是由软件的多个用户在一个或多个用户的实际使用环境下进行的测试。这些用户是与公司签定了支持产品预发行合同的外部客户。与α测试不同的是，开发者通常不在测试现场，由用户记下遇到的所有问题。开发者在综合用户的报告之后进行修改，最后将软件产品交付给全体用户使用。β测试主要衡量产品的FLURPS，着重于产品的支持性，包括文档、客户培训和支持产品生产能力。只有当α测试达到一定的可靠程度时，才能开始β测试。 </p>
</li>
<li><p>验收测试</p>
</li>
<li><p>确认结果测试</p>
</li>
</ol>
<h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><blockquote>
<p>系统测试（system testing）是将通过确认测试的软件，作为整个计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据、人员等其他系统元素结合在一起，在实际运行（使用）环境下，对计算机系统进行一系列的组装测试和确认测试。</p>
<p>系统测试的目的在于通过与系统的需求定义作比较，发现软件与系统定义不符合或与之矛盾的地方。系统测试的测试用例应根据系统的需求分析说明书设计，并在实际使用环境下运行。</p>
</blockquote>
<h4 id="测试的类型"><a href="#测试的类型" class="headerlink" title="测试的类型"></a>测试的类型</h4><p>（1）功能测试（function testing）：功能测试是在规定的一段时间内运行软件系统的所有功能，以验证这个软件系统有无严重错误。</p>
<p>（2）回归测试（regression testing）：这种测试用于验证对软件修改后有没有引出新的错误，或者说，验证修改后的软件是否仍然满足系统的需求规格说明。</p>
<p>（3）可靠性测试（reliability testing）：如果系统需求说明书中有对可靠性的要求，则需进行可靠性测试。通常使用平均失效间隔时间（MTBF）与因故障而停机的时间（MTTR）来度量系统的可靠性。 </p>
<p>（4）强度测试（stress testing）：也称压力测试，是要检查在系统运行环境恶劣的情况下，系统可以运行到何种程度的测试。因此，进行强度测试，需要提供非正常数量、频率或总量资源来运行系统。实际上，这是对软件的“超负荷”环境或临界环境的运行检验。</p>
<p>（5）性能测试（performance testing）：是要检查系统是否满足在需求说明书中规定的性能。特别是对于实时系统或嵌入式系统，软件只满足要求的功能而达不到要求的性能是不可接受的，所以还需要进行性能测试。</p>
<p>（6）恢复测试（recovery testing）：恢复测试是要证实在克服硬件故障（包括掉电、硬件或网络出错等）后，系统能否正常地继续进行工作，并不对系统造成任何损害。</p>
<p>（7）启动&#x2F;停止测试（startup&#x2F;shutdown testing）：这类测试的目的是验证在机器启动及关机阶段，软件系统正确处理的能力。包括反复启动软件系统（例如，操作系统自举、网络的启动、应用程序的调用等），以及在尽可能多的情况下关机。</p>
<p>（8）配置测试（configuration testing）：这类测试是要检查计算机系统内各个设备或各种资源之间的相互连接和功能分配中的错误。配置测试主要包括以下3种。</p>
<p>  ① 配置命令测试：验证全部配置命令的可操作性（有效 </p>
<p>  性）；特别对最大配置和最小配置要进行测试。软件配置 </p>
<p>  和硬件配置都要测试。</p>
<p>  ② 循环配置测试：证明对每个设备物理与逻辑的、逻辑</p>
<p>  与功能的每次循环置换配置都能正常工作。</p>
<p>  ③ 修复测试：检查每种配置状态及哪个设备是坏的，并 </p>
<p>  用自动的或手工的方式进行配置状态间的转换。</p>
<p>（9）安全性测试（security testing）：检验在系统中已经存在的系统安全性和保密性措施是否发挥作用，有无漏洞。为此要了解破坏安全性的方法和工具，并设计一些模拟测试用例对系统进行测试，力图破坏系统的保护机构以进入系统。</p>
<p>（10）可使用性测试（usability testing）：可使用性测试主要从使用的合理性、方便性等角度对软件系统进行检查，以发现人为因素或使用上的问题。</p>
<p>（11）可支持性测试（supportability testing）：验证系统的支持策略对于公司与用户方面是否切实可行。它所采用的方法是试运行支持过程（如对有错部分打补丁的过程，热线界面等），对其结果进行质量分析，评审诊断工具、维护过程、内部维护文档；衡量修复一个明显错误所需的平均最少时间。还有一种常用的方法是，在发行前把产品交给用户，向用户提供支持服务的计划，从用户处得到对支持服务的反馈。</p>
<p>（12）安装测试（installation testing）：安装测试的目的不是查找软件错误，而是查找安装错误。在安装软件系统时，会有多种选择。要分配和装入文件与程序库，布置适用的硬件配置，进行程序的连接。而安装测试是要查找出在这些安装过程中出现的错误。</p>
<p>（13）互连测试（interoperability testing）：验证两个或多个不同的系统之间的互连性。这类测试对支持标准规格说明，或承诺支持与其他系统互连的软件系统有效。</p>
<p>（14）兼容性测试（compatibility testing）：验证软件产品在不同版本之间的兼容性。有两类基本的兼容性测试：向下兼容和交错兼容。向下兼容测试是测试软件新版本，保留它早期版本的功能的情况；交错兼容测试是要验证共同存在的两个相关但不同的产品之间的兼容性。</p>
<p>（15）容量测试（volume testing）：容量测试是要检验系统的能力最高能达到什么程度。</p>
<p>（16）文档测试（documentation testing）：检查用户文档（如用户手册）的清晰性和精确性。用户文档中所使用的例子必须在测试中一一试过，确保叙述正确无误。</p>
<h2 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h2><h3 id="软件维护的概念"><a href="#软件维护的概念" class="headerlink" title="软件维护的概念"></a>软件维护的概念</h3><blockquote>
<p>软件维护是指在软件运行&#x2F;维护阶段对软件产品所进行的修改就是所谓的维护。</p>
</blockquote>
<p>根据维护工作的性质，软件维护的活动可以分为以下4种类型。</p>
<ul>
<li>改正性维护</li>
<li>适应性维护</li>
<li>完善性维护</li>
<li>预防性维护</li>
</ul>
<img src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/image-20240103235351538.png" alt="image-20240103235351538" style="zoom:50%;" />



<h4 id="改正性维护"><a href="#改正性维护" class="headerlink" title="改正性维护"></a>改正性维护</h4><blockquote>
<p>改正性维护（corrective maintenance）为了识别和纠正软件错误、改正软件性能上的缺陷、排除实施中的误使用，应进行的诊断和改正错误的过程。例如，改正性维护可以是改正原来程序中开关使用的错误；解决开发时未能测试各种可能情况带来的问题等。 </p>
</blockquote>
<h4 id="适应性维护"><a href="#适应性维护" class="headerlink" title="适应性维护"></a>适应性维护</h4><blockquote>
<p>随着信息技术的飞速发展，软件运行的外部环境（新的硬、软件配置）或数据环境（数据库、数据格式、数据输入&#x2F;输出方式、数据存储介质）可能发生变化，为了使软件适应这种变化，而修改软件的过程叫做适应性维护（adaptive maintenance）。例如，需要对已运行的软件进行改造，以适应网络环境或已升级改版的操作系统要求。</p>
</blockquote>
<h4 id="完善性维护"><a href="#完善性维护" class="headerlink" title="完善性维护"></a>完善性维护</h4><blockquote>
<p>为了满足新的功能与性能要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。这种情况下进行的维护活动叫做完善性维护（perfective maintenance）。</p>
</blockquote>
<h4 id="预防性维护"><a href="#预防性维护" class="headerlink" title="预防性维护"></a>预防性维护</h4><blockquote>
<p>预防性维护（preventive maintenance）是指把今天的方法学用于昨天的系统以满足明天的需要。也就是说，采用先进的软件工程方法对需要维护的软件或软件中的某一部分（重新）进行设计、编码和测试。</p>
</blockquote>
<h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><blockquote>
<p>重构就是在不改变代码外在行为的前提下，修改代码来改进程序的内部结构，提高程序的可理解性和可维护性等，进而帮助尽早的发现缺陷，提高编程速度。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.hu1hu.top">hu1hu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.hu1hu.top/posts/ishdl67348h/">https://www.hu1hu.top/posts/ishdl67348h/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.hu1hu.top" target="_blank">hu1hu的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></div><div class="post_share"><div class="social-share" data-image="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/软件工程.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/idek234jld/" title="高性能云计算复习"><img class="cover" src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/R.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">高性能云计算复习</div></div></a></div><div class="next-post pull-right"><a href="/posts/4600/" title="为Typora大纲与标题配置序号"><img class="cover" src="https://img.zcool.cn/community/01b3d35a3b5fb2a801201a1fe7fc92.gif" data-original="http://hu1hu-markdown.oss-cn-heyuan.aliyuncs.com/images/Typora-review.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">为Typora大纲与标题配置序号</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">软件与软件工程介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%89%B9%E6%80%A7%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">软件的概念、特性和分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA"><span class="toc-number">1.2.</span> <span class="toc-text">软件危机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">软件工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">1.4.</span> <span class="toc-text">软件生存期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">软件定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">问题定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">可行性研究</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">需求分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"><span class="toc-number">1.4.2.</span> <span class="toc-text">软件开发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">概要设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">详细设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81%E5%92%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">程序编码和单元测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">集成测试和系统测试</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%B4%E6%8A%A4"><span class="toc-number">1.4.3.</span> <span class="toc-text">运行维护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E6%96%87%E6%A1%A3"><span class="toc-number">1.4.4.</span> <span class="toc-text">典型文档</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA"><span class="toc-number">1.5.</span> <span class="toc-text">软件工程化方法概论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">软件生存期模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%96%87%E6%A1%A3%E9%A9%B1%E5%8A%A8%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">瀑布模型（文档驱动）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">传统的瀑布模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%9A%84%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">实际的瀑布模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.1.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.4.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.1.5.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">快速原型模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">增量模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%A3%8E%E9%99%A9%E9%A9%B1%E5%8A%A8%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">螺旋模型（风险驱动）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">迭代模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E4%B8%8E%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text">敏捷开发方法与极限编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E5%8E%9F%E5%88%99"><span class="toc-number">2.6.1.</span> <span class="toc-text">敏捷原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMM-CMMI"><span class="toc-number">2.7.</span> <span class="toc-text">CMM&#x2F;CMMI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMM"><span class="toc-number">2.7.1.</span> <span class="toc-text">CMM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMMI"><span class="toc-number">2.7.2.</span> <span class="toc-text">CMMI</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">软件需求获取与结构化分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%8E%9F%E5%88%99"><span class="toc-number">3.1.</span> <span class="toc-text">需求获取的任务和原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">结构化分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%BB%BA%E6%A8%A1"><span class="toc-number">3.2.1.</span> <span class="toc-text">功能建模</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1"><span class="toc-number">3.2.2.</span> <span class="toc-text">数据建模</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">数据对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1"><span class="toc-number">3.2.3.</span> <span class="toc-text">行为建模</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">结构化设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E5%88%99"><span class="toc-number">4.1.</span> <span class="toc-text">软件设计的概念与原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">4.1.1.</span> <span class="toc-text">软件设计的原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">分而治之</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">模块独立性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">提高抽象层次</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">复用性设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.1.1.5.</span> <span class="toc-text">灵活性设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.2.</span> <span class="toc-text">结构化设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.2.1.</span> <span class="toc-text">软件设计的任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.3.</span> <span class="toc-text">体系结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">基于数据流方法的设计过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">4.4.</span> <span class="toc-text">程序流程图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E7%AC%A6%E5%8F%B7"><span class="toc-number">4.4.1.</span> <span class="toc-text">标志符号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#McCabe%E5%BA%A6%E9%87%8F%E6%B3%95"><span class="toc-number">4.4.2.</span> <span class="toc-text">McCabe度量法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8EUML"><span class="toc-number">5.</span> <span class="toc-text">面向对象方法与UML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">UML简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">UML基本模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E7%9A%84%E4%BA%8B%E7%89%A9"><span class="toc-number">5.3.</span> <span class="toc-text">UML的事物</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BA%8B%E7%89%A9"><span class="toc-number">5.3.1.</span> <span class="toc-text">结构事物</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E4%BA%8B%E7%89%A9"><span class="toc-number">5.3.2.</span> <span class="toc-text">行为事物</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%8B%E7%89%A9"><span class="toc-number">5.3.3.</span> <span class="toc-text">分组事物</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E4%BA%8B%E7%89%A9"><span class="toc-number">5.3.4.</span> <span class="toc-text">注释事物</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.4.</span> <span class="toc-text">UML的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">5.4.1.</span> <span class="toc-text">依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-number">5.4.2.</span> <span class="toc-text">关联关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E5%90%88"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">聚合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB%EF%BC%88%E7%BB%A7%E6%89%BF%EF%BC%89"><span class="toc-number">5.4.3.</span> <span class="toc-text">泛化关系（继承）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%EF%BC%88%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">5.4.4.</span> <span class="toc-text">实现关系（实现）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E7%9A%84%E5%9B%BE"><span class="toc-number">5.5.</span> <span class="toc-text">UML的图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%9B%BE"><span class="toc-number">5.5.1.</span> <span class="toc-text">用例图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE"><span class="toc-number">5.5.2.</span> <span class="toc-text">类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%9B%BE"><span class="toc-number">5.5.3.</span> <span class="toc-text">交互图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%9B%BE%EF%BC%88%E6%97%B6%E5%BA%8F%E5%9B%BE%E3%80%81%E5%BA%8F%E5%88%97%E5%9B%BE%EF%BC%89"><span class="toc-number">5.5.3.1.</span> <span class="toc-text">顺序图（时序图、序列图）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%9B%BE%EF%BC%88%E5%8D%8F%E4%BD%9C%E5%9B%BE%EF%BC%89"><span class="toc-number">5.5.3.2.</span> <span class="toc-text">通信图（协作图）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="toc-number">5.5.4.</span> <span class="toc-text">状态图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%9B%BE"><span class="toc-number">5.5.5.</span> <span class="toc-text">活动图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E4%BB%B6%E5%9B%BE"><span class="toc-number">5.5.6.</span> <span class="toc-text">构件图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E5%9B%BE"><span class="toc-number">5.5.7.</span> <span class="toc-text">部署图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">面向对象分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">面向对象分析概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%B3%BB%E7%BB%9F%E8%BE%B9%E7%95%8C"><span class="toc-number">6.1.1.</span> <span class="toc-text">确定系统边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E7%9A%843%E7%A7%8D%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.2.</span> <span class="toc-text">面向对象分析的3种模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E7%94%A8%E4%BE%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">建立用例模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.1.</span> <span class="toc-text">过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">建立对象模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%845%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="toc-number">6.3.1.</span> <span class="toc-text">对象模型的5个层次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.4.</span> <span class="toc-text">建立动态模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">软件体系结构与设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">创建型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Method%EF%BC%89"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">工厂方法模式（Factory Method）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Abstract-Factory%EF%BC%89"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">抽象工厂模式（Abstract Factory）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%9E%8B"><span class="toc-number">7.1.2.</span> <span class="toc-text">构造型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter%E3%80%81Wrapper%E3%80%81Translator%EF%BC%89"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">适配器模式（Adapter、Wrapper、Translator）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B"><span class="toc-number">7.1.3.</span> <span class="toc-text">行为型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer-or-Publish-subscribe%EF%BC%89"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">观察者模式（Observer or Publish&#x2F;subscribe）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%BB%91%E6%9D%BF%E6%A8%A1%E5%BC%8F-Blackboard-Design-Pattern"><span class="toc-number">7.1.3.1.1.</span> <span class="toc-text">黑板模式(Blackboard Design Pattern)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy%EF%BC%89"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">策略模式（Strategy）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.</span> <span class="toc-text">面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">8.1.</span> <span class="toc-text">软件设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">8.1.1.</span> <span class="toc-text">单一职责原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">8.1.2.</span> <span class="toc-text">开闭原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">8.1.3.</span> <span class="toc-text">里式替换原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">8.1.4.</span> <span class="toc-text">依赖倒置原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99"><span class="toc-number">8.1.5.</span> <span class="toc-text">迪米特原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">8.1.6.</span> <span class="toc-text">接口隔离原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88-%E8%81%9A%E5%90%88%E5%8E%9F%E5%88%99"><span class="toc-number">8.1.7.</span> <span class="toc-text">组合&#x2F;聚合原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">软件测试方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">软件测试的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.2.</span> <span class="toc-text">白盒测试的测试用例设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96"><span class="toc-number">9.2.1.</span> <span class="toc-text">逻辑覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E8%A6%86%E7%9B%96"><span class="toc-number">9.2.2.</span> <span class="toc-text">语句覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E8%A6%86%E7%9B%96"><span class="toc-number">9.2.3.</span> <span class="toc-text">判定覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96"><span class="toc-number">9.2.4.</span> <span class="toc-text">条件覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A-%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96"><span class="toc-number">9.2.5.</span> <span class="toc-text">判定-条件覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BB%84%E5%90%88%E8%A6%86%E7%9B%96"><span class="toc-number">9.2.6.</span> <span class="toc-text">条件组合覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95"><span class="toc-number">9.2.7.</span> <span class="toc-text">路径测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96"><span class="toc-number">9.3.</span> <span class="toc-text">基本路径覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.4.</span> <span class="toc-text">黑盒测试的测试用例设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86"><span class="toc-number">9.4.1.</span> <span class="toc-text">等价类划分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%92%E5%88%86%E7%AD%89%E4%BB%B7%E7%B1%BB"><span class="toc-number">9.4.1.1.</span> <span class="toc-text">划分等价类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">9.4.1.2.</span> <span class="toc-text">确定测试用例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90"><span class="toc-number">9.4.2.</span> <span class="toc-text">边界值分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5"><span class="toc-number">9.5.</span> <span class="toc-text">软件测试策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">9.5.1.</span> <span class="toc-text">单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9"><span class="toc-number">9.5.1.1.</span> <span class="toc-text">单元测试内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.5.1.2.</span> <span class="toc-text">单元测试步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E8%A3%85%E6%B5%8B%E8%AF%95"><span class="toc-number">9.5.2.</span> <span class="toc-text">组装测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E6%B5%8B%E8%AF%95"><span class="toc-number">9.5.3.</span> <span class="toc-text">确认测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">9.5.4.</span> <span class="toc-text">系统测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.5.5.</span> <span class="toc-text">测试的类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4"><span class="toc-number">10.</span> <span class="toc-text">软件维护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.</span> <span class="toc-text">软件维护的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E6%AD%A3%E6%80%A7%E7%BB%B4%E6%8A%A4"><span class="toc-number">10.1.1.</span> <span class="toc-text">改正性维护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E6%80%A7%E7%BB%B4%E6%8A%A4"><span class="toc-number">10.1.2.</span> <span class="toc-text">适应性维护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E6%80%A7%E7%BB%B4%E6%8A%A4"><span class="toc-number">10.1.3.</span> <span class="toc-text">完善性维护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%80%A7%E7%BB%B4%E6%8A%A4"><span class="toc-number">10.1.4.</span> <span class="toc-text">预防性维护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%9E%84"><span class="toc-number">10.1.5.</span> <span class="toc-text">重构</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By hu1hu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://www.hu1hu.top/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="/js/headerNumbering.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>